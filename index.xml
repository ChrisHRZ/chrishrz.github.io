<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Focus-ChrisHRZ&#39;s blog</title>
    <link>https://chrishrz.github.io/</link>
    <description>Recent content on Focus-ChrisHRZ&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 27 Mar 2020 22:34:03 +0800</lastBuildDate>
    
	<atom:link href="https://chrishrz.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[lc]#113路径总和2</title>
      <link>https://chrishrz.github.io/post/lct113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C2/</link>
      <pubDate>Fri, 27 Mar 2020 22:34:03 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C2/</guid>
      <description>题目 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 给定如下二</description>
    </item>
    
    <item>
      <title>阿勒泰之春</title>
      <link>https://chrishrz.github.io/post/%E9%98%BF%E5%8B%92%E6%B3%B0%E4%B9%8B%E6%98%A5/</link>
      <pubDate>Sun, 22 Mar 2020 16:57:16 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/%E9%98%BF%E5%8B%92%E6%B3%B0%E4%B9%8B%E6%98%A5/</guid>
      <description>阿勒泰市北部为阿尔泰山地，南部为额尔齐斯河支流克兰河流域平原。 阿勒泰市属温带半干旱气候。四季分明，日照充足。冬长严寒，夏季温热，春秋短暂。1</description>
    </item>
    
    <item>
      <title>[lc]t112路径总和</title>
      <link>https://chrishrz.github.io/post/lct112%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</link>
      <pubDate>Fri, 20 Mar 2020 20:06:36 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct112%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</guid>
      <description>题目 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的</description>
    </item>
    
    <item>
      <title>[lc]t111二叉树的最小深度</title>
      <link>https://chrishrz.github.io/post/lct111%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Wed, 18 Mar 2020 17:10:27 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct111%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</guid>
      <description>题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二</description>
    </item>
    
    <item>
      <title>[lc]#110平衡二叉树</title>
      <link>https://chrishrz.github.io/post/lct110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 17 Mar 2020 16:32:45 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1</description>
    </item>
    
    <item>
      <title>[lc]#174二叉树的层次遍历2</title>
      <link>https://chrishrz.github.io/post/lct174%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%862/</link>
      <pubDate>Tue, 17 Mar 2020 14:01:58 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct174%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%862/</guid>
      <description>题目 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如： 给定二叉树 [3,9,20,null,null,15,7] 3 / \ 9 20 /</description>
    </item>
    
    <item>
      <title>[lc]#104二叉树的最大深度</title>
      <link>https://chrishrz.github.io/post/lct104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Tue, 17 Mar 2020 13:12:19 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid>
      <description>题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二</description>
    </item>
    
    <item>
      <title>[lc]#103二叉树的锯齿层次遍历</title>
      <link>https://chrishrz.github.io/post/lct103%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</link>
      <pubDate>Tue, 17 Mar 2020 11:48:54 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct103%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</guid>
      <description>题目 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如： 给定二叉树</description>
    </item>
    
    <item>
      <title>[转载]在hugo中使用mathjax</title>
      <link>https://chrishrz.github.io/post/%E8%BD%AC%E8%BD%BD%E5%9C%A8hugo%E4%B8%AD%E4%BD%BF%E7%94%A8mathjax/</link>
      <pubDate>Mon, 16 Mar 2020 19:47:24 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/%E8%BD%AC%E8%BD%BD%E5%9C%A8hugo%E4%B8%AD%E4%BD%BF%E7%94%A8mathjax/</guid>
      <description>在Hugo中使用MathJax 在博客中写公式中想直接使用latex,找了一圈发现hugo本身是不支持的,查阅到匿蟒前辈写的一篇博客,详细介绍</description>
    </item>
    
    <item>
      <title>[lc]#102二叉树的层次遍历</title>
      <link>https://chrishrz.github.io/post/lct102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sun, 15 Mar 2020 15:03:26 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</guid>
      <description>题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 队列迭代法 class Solution {//两种方法。1、队列迭代法。 public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; if(!root) return res; //定</description>
    </item>
    
    <item>
      <title>[lc]#101对称二叉树</title>
      <link>https://chrishrz.github.io/post/lct101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sat, 14 Mar 2020 19:54:18 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 class Solution {//三种方法。1、递归法。有点像#100 public: bool isSymmetric(TreeNode* root) { if(!root) return tru</description>
    </item>
    
    <item>
      <title>[lc]#100相同的树</title>
      <link>https://chrishrz.github.io/post/lct100%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</link>
      <pubDate>Sat, 14 Mar 2020 19:27:58 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct100%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</guid>
      <description>题解 这道题就是遍历。这里写一个先序遍历，其他遍历方式见相应例题。 二叉树的遍历包括DFS(深度优先搜索)的先序遍历、中序遍历、后序遍历。 还有B</description>
    </item>
    
    <item>
      <title>[lc]#98验证二叉搜索树</title>
      <link>https://chrishrz.github.io/post/lct98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sat, 14 Mar 2020 13:53:22 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题解 TreeNode的定义： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ 1. 直接递归法 class Solution {//三种方法。1、直接递归。利</description>
    </item>
    
    <item>
      <title>[lc]#95不同的二叉搜索树2</title>
      <link>https://chrishrz.github.io/post/lct95%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</link>
      <pubDate>Sat, 14 Mar 2020 00:59:26 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct95%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</guid>
      <description>题目 给定一个整数 n，生成所有由 1 &amp;hellip; n 为节点所组成的二叉搜索树。 示例: 输入: 3 输出: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] 解释: 以上的输出对应以下 5 种不同结构的二叉搜</description>
    </item>
    
    <item>
      <title>[转载]在hugo中添加mermaid支持</title>
      <link>https://chrishrz.github.io/post/%E8%BD%AC%E8%BD%BD%E5%9C%A8hugo%E4%B8%AD%E6%B7%BB%E5%8A%A0mermaid%E6%94%AF%E6%8C%81/</link>
      <pubDate>Fri, 13 Mar 2020 17:39:04 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/%E8%BD%AC%E8%BD%BD%E5%9C%A8hugo%E4%B8%AD%E6%B7%BB%E5%8A%A0mermaid%E6%94%AF%E6%8C%81/</guid>
      <description>在markdown中拓展mermaid 前面用有道云笔记的markdown功能，发现他画流程图非常好用。就想把这个功能加入到自己的blog中。</description>
    </item>
    
    <item>
      <title>[lc]#96不同的二叉搜索树</title>
      <link>https://chrishrz.github.io/post/lct96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Fri, 13 Mar 2020 12:26:13 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>给定一个整数 n，求以 1 &amp;hellip; n 为节点组成的二叉搜索树有多少种？ 示例： 输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \</description>
    </item>
    
    <item>
      <title>C&#43;&#43;哈希表unordered_map的常见方法小结</title>
      <link>https://chrishrz.github.io/post/c&#43;&#43;%E5%93%88%E5%B8%8C%E8%A1%A8unordered_map%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93/</link>
      <pubDate>Thu, 12 Mar 2020 22:34:40 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/c&#43;&#43;%E5%93%88%E5%B8%8C%E8%A1%A8unordered_map%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93/</guid>
      <description>unordered_map的常见用法 unordered_map &amp;lt;string,int&amp;gt; res; res.empty();//判断是否为空 res.size();//计算res的大小 res[&amp;quot;{key}&amp;quot;]; res.at(</description>
    </item>
    
    <item>
      <title>设置vscode的终端为cmder</title>
      <link>https://chrishrz.github.io/post/%E8%AE%BE%E7%BD%AEvscode%E7%9A%84%E7%BB%88%E7%AB%AF%E4%B8%BAcmder/</link>
      <pubDate>Thu, 12 Mar 2020 13:51:37 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/%E8%AE%BE%E7%BD%AEvscode%E7%9A%84%E7%BB%88%E7%AB%AF%E4%B8%BAcmder/</guid>
      <description>流程 1. 进入setting(ctrl+shift+p) 2. 依次进入User-&amp;gt;Features-&amp;gt;Terminal 3. 进入上图所示的E</description>
    </item>
    
    <item>
      <title>[lc]#94#144#145二叉树的三种遍历</title>
      <link>https://chrishrz.github.io/post/lct94t144t145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 09 Mar 2020 11:28:56 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct94t144t145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/</guid>
      <description>二叉树的遍历 简单地理解，满足以下两个条件的树就是二叉树： 本身是有序树； 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2； 下图即一颗二叉</description>
    </item>
    
    <item>
      <title>序</title>
      <link>https://chrishrz.github.io/post/first/</link>
      <pubDate>Mon, 09 Mar 2020 11:28:56 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/first/</guid>
      <description>ChrisHRZ的第一篇个人博客 写在前面 折腾了一天，终于搭建出来个人博客的雏形，过程还是挺有意思的。也算有了一片自己的领地。今天就这样了，后</description>
    </item>
    
  </channel>
</rss>