<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Focus-ChrisHRZ&#39;s blog</title>
    <link>https://chrishrz.github.io/</link>
    <description>Recent content on Focus-ChrisHRZ&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 11 Jul 2020 17:48:19 +0800</lastBuildDate>
    
	<atom:link href="https://chrishrz.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Lc]239滑动窗口最大值</title>
      <link>https://chrishrz.github.io/post/lc239%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</link>
      <pubDate>Sat, 11 Jul 2020 17:48:19 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc239%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</guid>
      <description>题目 题解 看题解有三个方法。最重要的是滑动窗口法，记录一下，其他的还有暴力法（超时）和动态规划法（没看懂，有时间再看） 1. 滑动窗口+单调递减队列</description>
    </item>
    
    <item>
      <title>[Lc]面试题59_I滑动窗口的最大值</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9859_i%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</link>
      <pubDate>Sat, 11 Jul 2020 17:42:23 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9859_i%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</guid>
      <description>题目 题解 看题解有三个方法。最重要的是滑动窗口法，记录一下，其他的还有暴力法（超时）和动态规划法（没看懂，有时间再看） 1. 滑动窗口+单调递减队列</description>
    </item>
    
    <item>
      <title>[Lc]面试题65不用加减乘除做加法</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9865%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</link>
      <pubDate>Sat, 11 Jul 2020 16:49:21 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9865%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</guid>
      <description>题目 题解 这道题要求不能使用四则运算，一般这种题就要用位运算。对加法进行分析一下 a b 新a（非进位和） 新b（c，进位位） 0 0 0 0 0 1 1 0 1 0 1 0</description>
    </item>
    
    <item>
      <title>[Lc]面试题61扑克牌中的顺子</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9861%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</link>
      <pubDate>Fri, 10 Jul 2020 16:51:50 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9861%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</guid>
      <description>题目 题解 两个方法。set去重+遍历和排序+遍历 这道题的核心是确定判断顺子的条件，有两个 数组中没有重复的数 最大值 - 最小值 &amp;lt; 5 1. set查重+遍历</description>
    </item>
    
    <item>
      <title>[Lc]面试题59_II队列的最大值</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9859_ii%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</link>
      <pubDate>Fri, 10 Jul 2020 16:07:07 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9859_ii%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</guid>
      <description>题目 //Your MaxQueue object will be instantiated and called as such: MaxQueue* obj = new MaxQueue(); int param_1 = obj-&amp;gt;max_value(); obj-&amp;gt;push_back(value); int param_3 = obj-&amp;gt;pop_front(); 题解 添加一个辅助的递减双端队列，用来保存对应队列中该数的最大值 push时： 当新添加的数小</description>
    </item>
    
    <item>
      <title>[Lc]面试题66构建乘积数组</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9866%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 07 Jul 2020 22:41:00 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9866%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</guid>
      <description>题目 题解 两个方法，其实本质是一个，第二个是第一个优化空间复杂度 1. 左右分开动态规划(双数组) 其实就是dp左右两边的数组，左边的从1开始到n-1</description>
    </item>
    
    <item>
      <title>[Lc]面试题60n个骰子的点数</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9860n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</link>
      <pubDate>Sat, 04 Jul 2020 14:08:27 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9860n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</guid>
      <description>题目 题解 这道题有两个方法，递归与动态规划，动态规划会超时。而且我刚开始看递归反而看不懂，因此转为先看动态规划，借助路漫漫我不畏的题解加图解，</description>
    </item>
    
    <item>
      <title>[Lc]面试题68_I二叉搜索树的最近公共祖先</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9868_i%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Fri, 03 Jul 2020 11:49:54 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9868_i%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>题目 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 题解 两个方法 这道题是236的子问题，多了二叉搜索树的限制。用236的方法也</description>
    </item>
    
    <item>
      <title>[Lc]235二叉搜索树的最近公共祖先</title>
      <link>https://chrishrz.github.io/post/lc235%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Fri, 03 Jul 2020 11:32:03 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc235%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>题目 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 题解 两个方法 这道题是236的子问题，多了二叉搜索树的限制。用236的方法也</description>
    </item>
    
    <item>
      <title>[Lc]236二叉树的最近公共祖先</title>
      <link>https://chrishrz.github.io/post/lc236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Thu, 02 Jul 2020 22:28:47 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>题目 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 题解 两个方法 1. 递归+后序遍历 直接用后续遍历对二叉树进行遍历，每次返回有以下</description>
    </item>
    
    <item>
      <title>[Lc]面试题68_II二叉树的最近公共祖先</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9868_ii%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Thu, 02 Jul 2020 22:18:17 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9868_ii%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>题目 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 题解 两个方法 1. 递归+后序遍历 直接用后续遍历对二叉树进行遍历，每次返回有以下</description>
    </item>
    
    <item>
      <title>[Lc]面试题64求1&#43;2&#43;…&#43;n</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9864%E6%B1%821&#43;2&#43;&#43;n/</link>
      <pubDate>Thu, 02 Jul 2020 10:53:01 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9864%E6%B1%821&#43;2&#43;&#43;n/</guid>
      <description>题目 题解 题目要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C） 递归一般要用条</description>
    </item>
    
    <item>
      <title>[Lc]面试题63股票的最大利润</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9863%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</link>
      <pubDate>Tue, 30 Jun 2020 11:22:21 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9863%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</guid>
      <description>题目 题解 动态规划的思想。即一次遍历，寻找两个数，一个是当前的全局最小值，一个是在当前的全局最小值后可以得到的最大差值 时间复杂度$O(n)$ 空</description>
    </item>
    
    <item>
      <title>[Lc]121买卖股票的最佳时机</title>
      <link>https://chrishrz.github.io/post/lc121%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</link>
      <pubDate>Tue, 30 Jun 2020 11:13:51 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc121%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</guid>
      <description>题目 题解 动态规划的思想。即一次遍历，寻找两个数，一个是当前的全局最小值，一个是在当前的全局最小值后可以得到的最大差值 时间复杂度$O(n)$ 空</description>
    </item>
    
    <item>
      <title>[Lc]面试题58_II左旋转字符串</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9858_ii%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 29 Jun 2020 22:31:23 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9858_ii%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目 题解 三个方法，都比较简单，直接看代码吧 1. 切片拼接法 时间复杂度$O(n)$ 空间复杂度$O(n)$ class Solution {//三个方法。1.切片拼接 public: string reverseLeftWords(string s, int</description>
    </item>
    
    <item>
      <title>[Lc]面试题62圆圈中最后剩下的数字</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9862%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Sat, 27 Jun 2020 12:33:08 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9862%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目 这道题是约瑟夫环可以用链表暴力删除，但是复杂度较高，是$O(mn)$ 1. 数学递推公式法 题解中大部分都是对这个递推公式的讲解，我的个人理解如</description>
    </item>
    
    <item>
      <title>[Lc]面试题58_I翻转单词顺序</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9858_i%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Sat, 27 Jun 2020 11:58:34 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9858_i%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</guid>
      <description>题目 题解 1. 双旋转单擦除法 题目要求空间复杂度$O(1)$，该方法符合，即先整体翻转全部字符串，再逐个单词串翻转，空格跳过，不同单词之间的空格自</description>
    </item>
    
    <item>
      <title>[Lc]面试题57_II和为s的连续正数序列</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9857_ii%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</link>
      <pubDate>Fri, 26 Jun 2020 22:21:12 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9857_ii%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</guid>
      <description>题目 题解 1. 暴力法 挨个计算所有数组的和，时间复杂度太高 时间复杂度: $O(n^{2})$ 空间复杂度: $O(1)$ 2. 滑动窗口法 看注释吧，不太难，证明可以看题解 时间复杂度: $O(n)$ 空</description>
    </item>
    
    <item>
      <title>[Lc]面试题57_I和为s的两个数字</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9857_i%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</link>
      <pubDate>Thu, 25 Jun 2020 20:09:52 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9857_i%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</guid>
      <description>题目 题解 可以用哈希表，但是需要用额外的存储空间，这道题有递增的性质，直接双指针，很简单，看代码就可以。 时间复杂度: $O(n)$ 空间复杂度: $O(1)$ class Solution { public: vector&amp;lt;int&amp;gt;</description>
    </item>
    
    <item>
      <title>[Lc]1两数之和</title>
      <link>https://chrishrz.github.io/post/lc1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Thu, 25 Jun 2020 19:30:14 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>题目 题解 1. 暴力法 就是挨个两两相加，找到相加为target的两个数。会超时，比较好写，这里不写了 时间复杂度$O(n^{2})$ 空间复杂度$O(</description>
    </item>
    
    <item>
      <title>[Lc]面试题56_II数组中数字出现的次数II</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9856_ii%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0ii/</link>
      <pubDate>Wed, 24 Jun 2020 17:09:28 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9856_ii%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0ii/</guid>
      <description>题目 题解 1. 有限状态机 详细题解看这里。这里放几张来自该题解的图。详细题解还是看 Krahets 大神的题解吧。 时间复杂度: $O(n)$ 空间复杂度: $O(1)$ 重点掌握one和tw</description>
    </item>
    
    <item>
      <title>[Lc]面试题56_I数组中数字出现的次数</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9856_i%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Wed, 24 Jun 2020 16:29:29 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9856_i%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</guid>
      <description>题目 题解 我们先来看下异或的性质（数学里异或的符号是 $\oplus$）： 交换律：$p \oplus q = q \oplus p$ 结合律：$p \oplus (q \oplus r) = (p \oplus q) \oplus r$ 恒等率：$p \oplus</description>
    </item>
    
    <item>
      <title>[Lc]面试题55_II平衡二叉树</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9855_ii%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Wed, 24 Jun 2020 15:56:16 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9855_ii%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 题解 详细题解可参见#110题解 1. 递归法 时间复杂度: $O(n\log n)$ 空间复杂度: $O(n)$ class Solution {</description>
    </item>
    
    <item>
      <title>[Lc]面试题55_I二叉树的深度</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9855_i%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Wed, 24 Jun 2020 12:32:08 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9855_i%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</guid>
      <description>题目 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 题解 详细题解可参见#104题解 1. 递归法 时间复杂度$O(N)$ 空间复杂度$O</description>
    </item>
    
    <item>
      <title>[Lc]面试题54二叉搜索树的第k大节点</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9854%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</link>
      <pubDate>Wed, 24 Jun 2020 10:34:14 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9854%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</guid>
      <description>题目 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 题解 **二叉搜索树的中序遍历是递增数组，那么二叉搜索树的中序遍历的倒序是递</description>
    </item>
    
    <item>
      <title>[Lc]133克隆图</title>
      <link>https://chrishrz.github.io/post/lc133%E5%85%8B%E9%9A%86%E5%9B%BE/</link>
      <pubDate>Tue, 23 Jun 2020 14:33:59 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc133%E5%85%8B%E9%9A%86%E5%9B%BE/</guid>
      <description>题目 图的定义如下： // Definition for a Node. class Node { public: int val; vector&amp;lt;Node*&amp;gt; neighbors; Node() { val = 0; neighbors = vector&amp;lt;Node*&amp;gt;(); } Node(int _val) { val = _val; neighbors = vector&amp;lt;Node*&amp;gt;(); } Node(int _val, vector&amp;lt;Node*&amp;gt; _neighbors) { val = _val; neighbors = _neighbors; } }; 题解 两个方法。DFS，BFS 1. DFS</description>
    </item>
    
    <item>
      <title>[Lc]面试题53_II</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9853_ii.0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Tue, 23 Jun 2020 14:10:37 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9853_ii.0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目 题解 1. 挨个查找法 时间复杂度$O(N)$ 空间复杂度$O(1)$ 就是挨个查找数组，找到与下标不一致的数即可，但不是最右的方法 2. 二分查找法 时间</description>
    </item>
    
    <item>
      <title>[Lc]面试题53_I在排序数组中查找数字I</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9853_i%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97i/</link>
      <pubDate>Mon, 22 Jun 2020 20:02:46 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9853_i%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97i/</guid>
      <description>题目 题解 1. 挨个查找法 时间复杂度$O(N)$ 空间复杂度$O(1)$ 就是挨个查找数组，找到的第一个就是开始位置，找到的最后一个就是结束位置。 这个</description>
    </item>
    
    <item>
      <title>[Lc]34在排序数组中查找元素的第一个和最后一个位置</title>
      <link>https://chrishrz.github.io/post/lc34%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Mon, 22 Jun 2020 19:42:13 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc34%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</guid>
      <description>题目 题解 1. 挨个查找法 时间复杂度$O(N)$ 空间复杂度$O(1)$ 就是挨个查找数组，找到的第一个就是开始位置，找到的最后一个就是结束位置。 这个</description>
    </item>
    
    <item>
      <title>[Lc]面试题52两个链表的第一个公共节点</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9852%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sun, 21 Jun 2020 21:18:04 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9852%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</guid>
      <description>题目 链表定义： //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 题解 1. 双指针法交替遍历 时间复杂度$O(n)$ 空间复杂度$O(1)$ 从两个链表的表头开始遍历</description>
    </item>
    
    <item>
      <title>[Lc]160相交链表</title>
      <link>https://chrishrz.github.io/post/lc160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 21 Jun 2020 17:50:26 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 链表定义： //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 题解 1. 双指针法交替遍历 时间复杂度$O(n)$ 空间复杂度$O(1)$ 从两个链表的表头开始遍历</description>
    </item>
    
    <item>
      <title>[Lc]面试题51数组中的逆序对</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9851%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</link>
      <pubDate>Sun, 14 Jun 2020 17:31:50 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9851%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</guid>
      <description>题目 题解 三个方法 1. 暴力法 必超时，挨个比较每两个数 时间复杂度$O(n^{2})$ 空间复杂度$O(1)$ 2. 归并排序法 就是用归并排序的思想，在归并</description>
    </item>
    
    <item>
      <title>[Lc]面试题50第一个只出现一次的字符</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9850%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Fri, 12 Jun 2020 19:14:08 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9850%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</guid>
      <description>题目 题解 三个方法，前两个都是基于哈希表，只是哈希表的实现方式不同；最后一个是对于数据流的处理情况，这个情况只能遍历字符串一遍，因此需要再遍历</description>
    </item>
    
    <item>
      <title>[Lc]263丑数</title>
      <link>https://chrishrz.github.io/post/lc263%E4%B8%91%E6%95%B0/</link>
      <pubDate>Fri, 12 Jun 2020 17:32:36 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc263%E4%B8%91%E6%95%B0/</guid>
      <description>题目 题解 除就完事了，使劲除，除到原始丑数都没法除 时间复杂度$O(n)$，不太确定 空间复杂度$O(1)$ class Solution {//一个方法。1.因式分解 public: bool isUgly(int</description>
    </item>
    
    <item>
      <title>[Lc]264丑数II</title>
      <link>https://chrishrz.github.io/post/lc264%E4%B8%91%E6%95%B0ii/</link>
      <pubDate>Fri, 12 Jun 2020 17:26:30 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc264%E4%B8%91%E6%95%B0ii/</guid>
      <description>题目 题解 两个方法 1. 动态规划 就是找到丑数的生成规律，然后递推不断地生成下一个丑数，直到生成第n个丑数，需要使用三个指针，分析见注释 时间复杂度$</description>
    </item>
    
    <item>
      <title>[Lc]面试题49丑数</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9849%E4%B8%91%E6%95%B0/</link>
      <pubDate>Fri, 12 Jun 2020 16:50:55 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9849%E4%B8%91%E6%95%B0/</guid>
      <description>题目 题解 两个方法 1. 动态规划 就是找到丑数的生成规律，然后递推不断地生成下一个丑数，直到生成第n个丑数，需要使用三个指针，分析见注释 时间复杂度$</description>
    </item>
    
    <item>
      <title>[Lc]面试题48最长不含重复字符的子字符串</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9848%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Fri, 12 Jun 2020 12:30:43 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9848%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目 题解 这道题是用滑动窗口法，用一个哈希表（或者vector或者unordered_set）存已经遍历过的字符和最近出现该字符的位置 若重复遇</description>
    </item>
    
    <item>
      <title>[Lc]3无重复字符的最长子串</title>
      <link>https://chrishrz.github.io/post/lc3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Fri, 12 Jun 2020 11:06:15 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid>
      <description>题目 题解 这道题是用滑动窗口法，用一个哈希表（或者vector或者unordered_set）存已经遍历过的字符和最近出现该字符的位置 若重复遇</description>
    </item>
    
    <item>
      <title>[Lc]面试题47礼物的最大价值</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9847%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</link>
      <pubDate>Thu, 11 Jun 2020 22:21:58 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9847%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</guid>
      <description>题目 题解 这道题感觉做过类似的，忘了是哪一道了，反正就是原地动态规划，原地更新数组，边界直接加上左（或上）的数，中间的加左或上中比较大的数比较</description>
    </item>
    
    <item>
      <title>[Lc]面试题46把数字翻译成字符串</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9846%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 11 Jun 2020 22:07:48 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9846%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目 题解 这道题和91题很像，区别在于这道题从0开始编码，就不用讨论当前数为0的情况，因此更简单，可以转化为字符串使用91题的方法进行解决，这</description>
    </item>
    
    <item>
      <title>[Lc]面试题45把数组排成最小的数</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9845%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</link>
      <pubDate>Thu, 11 Jun 2020 15:11:58 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9845%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</guid>
      <description>题目 题解 这道题实际上是字符串排序，需要重新定义字符串大小的定义 ，具体的排序方法见注释 时间复杂度$O(nlog{n})$ 空间复杂度$O(n)$</description>
    </item>
    
    <item>
      <title>[Lc]400第N个数字</title>
      <link>https://chrishrz.github.io/post/lc400%E7%AC%ACn%E4%B8%AA%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 10 Jun 2020 18:08:08 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc400%E7%AC%ACn%E4%B8%AA%E6%95%B0%E5%AD%97/</guid>
      <description>题目 题解 这道题主要是找规律，图示可以看这里 先剔除掉0 1~9， 有9*1=9个数字，占9*1*1=9个数位 10~99， 有9*10=90个数字，占</description>
    </item>
    
    <item>
      <title>[Lc]面试题44数字序列中某一位的数字</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9844%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 10 Jun 2020 17:49:09 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9844%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目 题解 这道题主要是找规律，图示可以看这里 先剔除掉0 1~9， 有9*1=9个数字，占9*1*1=9个数位 10~99， 有9*10=90个数字，占</description>
    </item>
    
    <item>
      <title>[Lc]233数字1的个数</title>
      <link>https://chrishrz.github.io/post/lc233%E6%95%B0%E5%AD%971%E7%9A%84%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Wed, 10 Jun 2020 17:39:53 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc233%E6%95%B0%E5%AD%971%E7%9A%84%E4%B8%AA%E6%95%B0/</guid>
      <description>题目 题解 这题可以用暴力法，即挨个数字统计，必定超时 时间复杂度：$O(n*log_{10}(n))$ 从 1 遍历到 n。 每次遍历中，我们把整数转成字</description>
    </item>
    
    <item>
      <title>[Lc]面试题43整数中1出现的次数</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9843%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Wed, 10 Jun 2020 12:27:15 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9843%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</guid>
      <description>题目 题解 这题可以用暴力法，即挨个数字统计，必定超时 时间复杂度：$O(n*log_{10}(n))$ 从 1 遍历到 n。 每次遍历中，我们把整数转成字</description>
    </item>
    
    <item>
      <title>[Lc]面试题42连续子数组的最大和</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9842%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</link>
      <pubDate>Sat, 06 Jun 2020 22:21:20 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9842%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</guid>
      <description>题目 题解 这题有三种解法，其中第一种暴力法肯定超时，因此主要讨论后两种方法 1. 暴力法 这个方法就是取每种情况并计算当前情况的子序和，时间复杂度达到</description>
    </item>
    
    <item>
      <title>[Lc]53最大子序和</title>
      <link>https://chrishrz.github.io/post/lc53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</link>
      <pubDate>Sat, 06 Jun 2020 20:37:44 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</guid>
      <description>题目 题解 这题有三种解法，其中第一种暴力法肯定超时，因此主要讨论后两种方法 1. 暴力法 这个方法就是取每种情况并计算当前情况的子序和，时间复杂度达到</description>
    </item>
    
    <item>
      <title>[转载]C&#43;&#43;子类的构造函数后面加冒号的作用</title>
      <link>https://chrishrz.github.io/post/%E8%BD%AC%E8%BD%BDc&#43;&#43;%E5%AD%90%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%90%8E%E9%9D%A2%E5%8A%A0%E5%86%92%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</link>
      <pubDate>Sat, 06 Jun 2020 18:32:36 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/%E8%BD%AC%E8%BD%BDc&#43;&#43;%E5%AD%90%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%90%8E%E9%9D%A2%E5%8A%A0%E5%86%92%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</guid>
      <description>在C++类的构造函数中经常会看到如下格式的写法： MyWindow::MyWindow(QWidget* parent , Qt::WindowFlags flag) : QMainWindow(parent,flag) 上述语句中单冒号(:)的作用是表示后面是初始化列表，一般有三种使用场景。 1. 对父</description>
    </item>
    
    <item>
      <title>[Lc]295数据流的中位数</title>
      <link>https://chrishrz.github.io/post/lc295%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Wed, 03 Jun 2020 18:17:03 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc295%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>题目 //Your MedianFinder object will be instantiated and called as such: MedianFinder* obj = new MedianFinder(); obj-&amp;gt;addNum(num); double param_2 = obj-&amp;gt;findMedian(); 题解 有三种方法 1. 插入排序法 在插入每一个数时使用插入排序的思路，这样在取数的时候只需要取中间的数（</description>
    </item>
    
    <item>
      <title>[Lc]面试题41数据流中的中位数</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9841%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Wed, 03 Jun 2020 18:16:44 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9841%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>题目 //Your MedianFinder object will be instantiated and called as such: MedianFinder* obj = new MedianFinder(); obj-&amp;gt;addNum(num); double param_2 = obj-&amp;gt;findMedian(); 题解 有三种方法 1. 插入排序法 在插入每一个数时使用插入排序的思路，这样在取数的时候只需要取中间的数（</description>
    </item>
    
    <item>
      <title>源码，反码，补码浅析</title>
      <link>https://chrishrz.github.io/post/%E6%BA%90%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E6%B5%85%E6%9E%90/</link>
      <pubDate>Fri, 22 May 2020 11:22:04 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/%E6%BA%90%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E6%B5%85%E6%9E%90/</guid>
      <description>源码，反码和补码的形式 以下三种码都是二进制码 **源码：**符号位+真值的绝对值。符号位0表示正数，1表示负数。 **反码：**正数时，反码=源</description>
    </item>
    
    <item>
      <title>[Lc]52N皇后II</title>
      <link>https://chrishrz.github.io/post/lc52n%E7%9A%87%E5%90%8Eii/</link>
      <pubDate>Thu, 21 May 2020 18:45:47 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc52n%E7%9A%87%E5%90%8Eii/</guid>
      <description>题目 题解 这道题是51题的化简版，这里贴上51题的思路。唯一的区别就说不用统计所有的棋盘情况，而是遍历完一个分支就计数+1 这道题是很经典的一道</description>
    </item>
    
    <item>
      <title>[Lc]51N皇后</title>
      <link>https://chrishrz.github.io/post/lc51n%E7%9A%87%E5%90%8E/</link>
      <pubDate>Thu, 21 May 2020 11:23:26 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc51n%E7%9A%87%E5%90%8E/</guid>
      <description>题目 题解 这道题是很经典的一道题，思路就是dfs与回溯剪枝。这类回溯题的递归函数基本套路是这样的 判断是否终止并满足条件，满足了就加入res中 遍</description>
    </item>
    
    <item>
      <title>[Lc]面试题39数组中出现次数超过一半的数字</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9839%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 20 May 2020 21:51:06 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9839%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目 题解 详细注释见169题，这里再练习一下 1. 排序取中法 时间复杂度$O(nlog{n})$，主要是排序耗费的 空间复杂度$O(1)$ class Solution {//三</description>
    </item>
    
    <item>
      <title>[Lc]169多数元素</title>
      <link>https://chrishrz.github.io/post/lc169%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</link>
      <pubDate>Wed, 20 May 2020 21:36:39 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc169%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</guid>
      <description>题目 题解 1. 排序取中法 时间复杂度$O(nlog{n})$，主要是排序耗费的 空间复杂度$O(1)$ class Solution {//三种方法，这是1.排序后取中间数 //</description>
    </item>
    
    <item>
      <title>[Lc]面试题38字符串的排列</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9838%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</link>
      <pubDate>Wed, 20 May 2020 20:57:28 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9838%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</guid>
      <description>题目 题解 整体思路是从第一个数开始，不断地与后面的数进行交换（这个交换也包括与自己交换，即不交换），每一个数都有s.size()-start种</description>
    </item>
    
    <item>
      <title>[Lc]面试题37序列化二叉树</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9837%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Wed, 20 May 2020 16:54:15 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9837%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 先序遍历法 按先序遍历的顺序对数组进行序列化，遇到nullptr记位#</description>
    </item>
    
    <item>
      <title>[Lc]297二叉树的序列化与反序列化</title>
      <link>https://chrishrz.github.io/post/lc297%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Wed, 20 May 2020 15:59:53 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc297%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 先序遍历法 按先序遍历的顺序对数组进行序列化，遇到nullptr记位#</description>
    </item>
    
    <item>
      <title>[Lc]面试题36二叉搜索树与双向链表</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9836%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 20 May 2020 12:05:20 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9836%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 题解 节点定义如下： // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node() {} Node(int _val) { val = _val; left = NULL; right = NULL; } Node(int _val, Node* _left, Node* _right) { val = _val; left = _left; right = _right; } }; 这道题要利用二叉搜索树</description>
    </item>
    
    <item>
      <title>[Lc]426将二叉搜索树转化为排序的双向链表</title>
      <link>https://chrishrz.github.io/post/lc426%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 20 May 2020 11:58:34 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc426%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 题解 节点定义如下： // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node() {} Node(int _val) { val = _val; left = NULL; right = NULL; } Node(int _val, Node* _left, Node* _right) { val = _val; left = _left; right = _right; } }; 这道题要利用二叉搜索树</description>
    </item>
    
    <item>
      <title>[Lc]138复制带随机指针的链表</title>
      <link>https://chrishrz.github.io/post/lc138%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 19 May 2020 20:06:03 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc138%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 题解 链表定义： // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; 1. 复制链表节点法 在每个节点后复制新的节点，三次遍历 先复制新的节点</description>
    </item>
    
    <item>
      <title>[Lc]面试题35复杂链表的复制</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9835%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Tue, 19 May 2020 20:02:50 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9835%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</guid>
      <description>题目 题解 链表定义： // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; 详细注释看138题 1. 复制链表节点法 在每个节点后复制新的节点，三次</description>
    </item>
    
    <item>
      <title>[Lc]面试题34二叉树中和为某一值的路径</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9834%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Tue, 19 May 2020 17:23:22 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9834%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description>题目 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 题解 这道题和113一样，可以用递归和迭代两种方法。这里再练习写一遍，详细题</description>
    </item>
    
    <item>
      <title>[Lc]面试题33二叉搜索树的后序遍历序列</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9833%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</link>
      <pubDate>Tue, 19 May 2020 12:13:21 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9833%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 分治递归法 二叉搜索树的性质见这里。后序遍历的顺序是左-&amp;gt;根-&amp;</description>
    </item>
    
    <item>
      <title>[Lc]面试题32_III从上到下打印二叉树III</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9832_iii%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91iii/</link>
      <pubDate>Mon, 18 May 2020 19:33:01 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9832_iii%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91iii/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 队列迭代法 比上一题再复杂一点，要区分奇偶行，偶数行从后面加数，奇数行</description>
    </item>
    
    <item>
      <title>[Lc]面试题32_II从上到下打印二叉树II</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9832_ii%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91ii/</link>
      <pubDate>Mon, 18 May 2020 19:24:27 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9832_ii%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91ii/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 队列迭代法 比上一题稍微复杂一点，不同层次要分开存，因此这里要多一个循</description>
    </item>
    
    <item>
      <title>[Lc]面试题32_I从上到下打印二叉树</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9832_i%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 18 May 2020 19:01:09 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9832_i%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 题解 其实就是二叉树的层次遍历，比102简单。因为这道题不分层因此用dfs不好做，还是用bfs好 时间复杂度$O(n)$ 空间复杂度$O(n)</description>
    </item>
    
    <item>
      <title>[Lc]面试题31栈的压入、弹出序列</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9831%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</link>
      <pubDate>Mon, 18 May 2020 18:45:41 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9831%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 这个就用一个栈来模拟压入，出栈就可以了。每存一个数要检查当前的popp</description>
    </item>
    
    <item>
      <title>[Lc]946验证栈序列</title>
      <link>https://chrishrz.github.io/post/lc946%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/</link>
      <pubDate>Mon, 18 May 2020 18:26:17 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc946%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/</guid>
      <description>题目 题解 这个就用一个栈来模拟压入，出栈就可以了。每存一个数要检查当前的popped数组的首位 时间复杂度$O(n)$ 空间复杂度$O(n)$ class Solution</description>
    </item>
    
    <item>
      <title>[Lc]面试题30包含min函数的栈</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9830%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</link>
      <pubDate>Mon, 18 May 2020 17:10:48 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9830%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</guid>
      <description>题目 题解 两个类似的方法，一个是使用辅助栈存当前的最小值，一个是直接用一个栈保存一个pari，包括原值和最小值，个人感觉后一种方法更加直观，即</description>
    </item>
    
    <item>
      <title>[Lc]155最小栈</title>
      <link>https://chrishrz.github.io/post/lc155%E6%9C%80%E5%B0%8F%E6%A0%88/</link>
      <pubDate>Mon, 18 May 2020 17:06:23 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc155%E6%9C%80%E5%B0%8F%E6%A0%88/</guid>
      <description>题目 题解 两个类似的方法，一个是使用辅助栈存当前的最小值，一个是直接用一个栈保存一个pair，包括原值和最小值，个人感觉后一种方法更加直观，即</description>
    </item>
    
    <item>
      <title>[Lc]54螺旋矩阵</title>
      <link>https://chrishrz.github.io/post/lc54%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Sun, 17 May 2020 17:10:02 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc54%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</guid>
      <description>题目 题解 就是分四种情况，从左到右，上到下，右到左，下到上循环遍历，和59题类似 时间复杂度$O(nm)$ 空间复杂度$O(nm)$ class Solution { public: vector&amp;lt;int&amp;gt; spiralOrder(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix)</description>
    </item>
    
    <item>
      <title>[Lc]59螺旋矩阵II</title>
      <link>https://chrishrz.github.io/post/lc59%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5ii/</link>
      <pubDate>Sun, 17 May 2020 17:07:32 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc59%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5ii/</guid>
      <description>题目 题解 就是分四种情况，从左到右，上到下，右到左，下到上循环遍历，和54题类似 时间复杂度$O(nm)$ 空间复杂度$O(nm)$ class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generateMatrix(int n)</description>
    </item>
    
    <item>
      <title>[Lc]面试题29顺时针打印矩阵</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9829%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Sun, 17 May 2020 17:07:04 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9829%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</guid>
      <description>题目 题解 直接迭代，四个方向将结果输入res，注意边界条件的判断 时间复杂度$O(n)$ 空间复杂度$O(n)$ class Solution { public: vector&amp;lt;int&amp;gt; spiralOrder(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { vector&amp;lt;int&amp;gt; res; if(matrix.empty()) return res; int u=0, d=matrix.size()-1, l=0,</description>
    </item>
    
    <item>
      <title>[Lc]面试题28对称的二叉树</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9828%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 17 May 2020 13:21:13 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9828%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 这道题三种解法，递归，栈迭代（先序遍历），队列迭代（层次遍历）。与10</description>
    </item>
    
    <item>
      <title>[Lc]面试题27二叉树的镜像</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9827%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link>
      <pubDate>Sat, 16 May 2020 11:31:08 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9827%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 这个方法就是递归的翻转左右子树，若遇到空子树直接返回，然后当前</description>
    </item>
    
    <item>
      <title>[Lc]面试题26树的子结构</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9826%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 15 May 2020 21:22:56 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9826%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 双递归法 两个递归函数，一个用来看当前节点是否匹配，一个用来遍历a的所</description>
    </item>
    
    <item>
      <title>[Lc]面试题25合并两个排序的链表</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9825%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 15 May 2020 17:43:28 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9825%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 链表定义： //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 题解 这道题的思想是链表归并排序中的一个重要环节，即对有序的两个链表进行归并。比较表头，小的</description>
    </item>
    
    <item>
      <title>[Lc]21合并两个有序链表</title>
      <link>https://chrishrz.github.io/post/lc21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 15 May 2020 17:36:13 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 链表定义： //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 题解 这道题的思想是链表归并排序中的一个重要环节，即对有序的两个链表进行归并。比较表头，小的</description>
    </item>
    
    <item>
      <title>[Lc]206反转链表</title>
      <link>https://chrishrz.github.io/post/lc206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 15 May 2020 17:08:28 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 链表定义： //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 题解 1. 迭代法（双指针） 实际上是三个指针，一个指向当前节点之前pre，一个指向当前节点cur</description>
    </item>
    
    <item>
      <title>[Lc]面试题24反转链表</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9824%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 15 May 2020 16:31:44 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9824%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 链表定义： //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 题解 1. 迭代法（双指针） 实际上是三个指针，一个指向当前节点之前pre，一个指向当前节点cur</description>
    </item>
    
    <item>
      <title>[Lc]面试题22链表中倒数第k个节点</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9822%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 14 May 2020 21:25:53 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9822%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>题目 题解 快慢指针 时间复杂度$O(n)$ 空间复杂度$O(1)$ class Solution { public: ListNode* getKthFromEnd(ListNode* head, int k) { if(k==0 || !head) return nullptr; ListNode *fast = head, *slow = head; int n = 0; while(fast){ if(n &amp;gt;= k) slow = slow-&amp;gt;next; fast = fast-&amp;gt;next; n++; } if(n&amp;lt;k) return</description>
    </item>
    
    <item>
      <title>[Lc]面试题21调整数组顺序使奇数位于偶数前面</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9821%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</link>
      <pubDate>Thu, 14 May 2020 21:14:29 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9821%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</guid>
      <description>题目 题解 双指针，左找到偶数，右找到奇数，然后交换，继续循环 时间复杂度$O(n)$ 空间复杂度$O(1)$，原地交换 class Solution { public: vector&amp;lt;int&amp;gt; exchange(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int p1=0, p2 = nums.size()-1; while(p1&amp;lt;p2){</description>
    </item>
    
    <item>
      <title>[Lc]面试题19正则表达式匹配</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9819%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Thu, 14 May 2020 13:17:07 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9819%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>题目 题解 1. 普通递归 class Solution { public: bool isMatch(string s, string p) { if(p.empty()) return s.empty();//若p为空，则s为空返回false。否则返回true //若s不为空且当前字符</description>
    </item>
    
    <item>
      <title>[Lc]10正则表达式匹配</title>
      <link>https://chrishrz.github.io/post/lc10%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Thu, 14 May 2020 13:13:40 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc10%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>题目 题解 1. 普通递归 class Solution { public: bool isMatch(string s, string p) { if(p.empty()) return s.empty();//若p为空，则s为空返回false。否则返回true //若s不为空且当前字符</description>
    </item>
    
    <item>
      <title>[Lc]面试题18删除链表的节点</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9818%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Wed, 13 May 2020 21:39:00 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9818%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>题目 链表定义： //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 题解 这题简单，两个指针，一个指向cur，一个是cur之前pre。当cur的值为val时，p</description>
    </item>
    
    <item>
      <title>[Lc]面试题17打印从1到最大的n位数</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9817%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Wed, 13 May 2020 16:08:43 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9817%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</guid>
      <description>题目 题解 这道题如果不考虑大数的话很简单，但是原书主要是解决输出大数的问题，因此大数也要加以练习（leetcode不考虑大树也能通过） 1. 普通解</description>
    </item>
    
    <item>
      <title>[Lc]面试题16数值的整数次方</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9816%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</link>
      <pubDate>Wed, 13 May 2020 12:58:28 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9816%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</guid>
      <description>题目 题解 这道题在leetcode上用挨个累乘的方法会超时因此需要用快速幂法 快速幂是指x**2n == x**n + x**n，利用这一性质，不断的一半的数进</description>
    </item>
    
    <item>
      <title>[Lc]191位1的个数</title>
      <link>https://chrishrz.github.io/post/lc191%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Wed, 13 May 2020 12:09:00 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc191%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</guid>
      <description>题目 题解 1. 位掩码 设置一个位掩码mask，初值为1，每次1向左移动一位，mask与n做与运算之后只有mask中为1的那一位为保留，其余归0。因</description>
    </item>
    
    <item>
      <title>[Lc]面试题15二进制中1的个数</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9815%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Wed, 13 May 2020 12:08:41 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9815%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</guid>
      <description>题目 题解 1. 位掩码 设置一个位掩码mask，初值为1，每次1向左移动一位，mask与n做与运算之后只有mask中为1的那一位为保留，其余归0。因</description>
    </item>
    
    <item>
      <title>[Lc]面试题14_II剪绳子II</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9814_ii%E5%89%AA%E7%BB%B3%E5%AD%90ii/</link>
      <pubDate>Wed, 13 May 2020 11:26:05 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9814_ii%E5%89%AA%E7%BB%B3%E5%AD%90ii/</guid>
      <description>题目 题解 这题写的我不行了，其实这题思路很简单，就是c++取余太麻烦了，我想写一个自己的pow()函数，用clion跑的结果和oj还不一样，取</description>
    </item>
    
    <item>
      <title>[Lc]343整数拆分</title>
      <link>https://chrishrz.github.io/post/lc343%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</link>
      <pubDate>Tue, 12 May 2020 17:51:35 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc343%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</guid>
      <description>题目 题解 1. 普通DP 具体思路看注释。前面遇到一个问题，即循环里dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j]));为什么不是dp[i], j*(i-j), dp[j]*dp[i-j] 这是因为在内循</description>
    </item>
    
    <item>
      <title>[Lc]面试题14_I剪绳子</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9814_i%E5%89%AA%E7%BB%B3%E5%AD%90/</link>
      <pubDate>Tue, 12 May 2020 13:12:27 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9814_i%E5%89%AA%E7%BB%B3%E5%AD%90/</guid>
      <description>题目 题解 1. 普通DP 具体思路看注释。前面遇到一个问题，即循环里dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j]));为什么不是dp[i], j*(i-j), dp[j]*dp[i-j] 这是因为在内循</description>
    </item>
    
    <item>
      <title>[Lc]面试题13机器人的运动范围</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9813%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</link>
      <pubDate>Mon, 11 May 2020 21:31:13 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9813%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</guid>
      <description>题目 题解 1. DFS 利用递归实现DFS搜索，注意要使用一个额外的矩阵保存已经访问过的位置，防止重复访问。当越界或者不满足数位条件或者已经访问过的时候</description>
    </item>
    
    <item>
      <title>[Lc]面试题12矩阵中的路径</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9812%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Mon, 11 May 2020 18:32:06 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9812%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description>题目 注意：本题与主站 79 题相同：(https://leetcode-cn.com/problems/word-search/) 题解 这道题用递归</description>
    </item>
    
    <item>
      <title>[Lc]79单词搜索</title>
      <link>https://chrishrz.github.io/post/lc79%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Mon, 11 May 2020 18:18:49 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc79%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</guid>
      <description>题目 题解 这道题用递归，DFS，找到和首字母相同的就继续找下去，找到不同的就回溯再找首字母 时间复杂度：${\mathcal{O}}((M\ti</description>
    </item>
    
    <item>
      <title>[Lc]面试题11旋转数组的最小数字</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9811%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</link>
      <pubDate>Mon, 11 May 2020 17:38:36 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9811%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</guid>
      <description>题目 注意：本题与主站 154 题相同：(https://leetcode-cn.com/problems/find-minimum-in-rotat</description>
    </item>
    
    <item>
      <title>[Lc]154寻找旋转排序数组中的最小值II</title>
      <link>https://chrishrz.github.io/post/lc154%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCii/</link>
      <pubDate>Mon, 11 May 2020 13:29:04 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc154%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCii/</guid>
      <description>题目 题解 这道题与153题类似，是其进阶，主要是出现了重复元素，因此要加上情况三的判断 如果中间的数小于最右边的数，则右半段是有序的,最小值在左</description>
    </item>
    
    <item>
      <title>[Lc]33搜索旋转排序数组</title>
      <link>https://chrishrz.github.io/post/lc33%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 11 May 2020 13:08:34 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc33%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>题目 题解 题目要求的复杂度一看就得联想到二分查找，这道题需要先分析一下如何二分查找，看下面的数组进行分析 如果中间的数小于最右边的数，则右半段是</description>
    </item>
    
    <item>
      <title>[Lc]153寻找旋转排序数组中的最小值</title>
      <link>https://chrishrz.github.io/post/lc153%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</link>
      <pubDate>Mon, 11 May 2020 13:05:17 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc153%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</guid>
      <description>题目 题解 这题与33题类似，33是查找，这一题是找最小值，也要利用旋转数组的性质 如果中间的数小于等于最右边的数，则右半段是有序的,最小值在左半</description>
    </item>
    
    <item>
      <title>[Lc]面试题10_II青蛙跳台阶问题</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9810_ii%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 11 May 2020 12:13:41 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9810_ii%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</guid>
      <description>题目 题解 这题与70题一样，详见70题题解，因为要取模，因此通项公式法无法通过，递推公式法也太慢通过不了，其分析详见70题题解，这里贴一个递推</description>
    </item>
    
    <item>
      <title>[Lc]509斐波那契数</title>
      <link>https://chrishrz.github.io/post/lc509%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</link>
      <pubDate>Mon, 11 May 2020 11:23:15 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc509%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</guid>
      <description>题目 题解 这题和爬楼梯是一样的，这题与剑指offer10一样，三种方法 1. 递归 这个方法最慢，因为有大量的重复运算，写法最简单，就不写了 时间复杂度</description>
    </item>
    
    <item>
      <title>[Lc]面试题10_I斐波那契数列</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9810_i%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</link>
      <pubDate>Mon, 11 May 2020 11:20:02 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9810_i%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</guid>
      <description>题目 题解 这题与[lc]509一样，区别在于结果需要取余，而对于最终结果取余和对于每一位取余再计算下一个数字答案是一样的。具体分析见(http</description>
    </item>
    
    <item>
      <title>[Lc]面试题09用两个栈实现队列</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9809%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link>
      <pubDate>Sun, 10 May 2020 20:54:36 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9809%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid>
      <description>题目 题解 腾讯的客户端开发就是面的这个。。。，当时还想了半天幸苦想出来了，可惜还是凉 //Your CQueue object will be instantiated and called as such: CQueue* obj = new CQueue(); bj-&amp;gt;appendTail(value); int param_2 = obj-&amp;gt;deleteHead(); 1. 快存慢取 这个方法</description>
    </item>
    
    <item>
      <title>[Lc]105从前序与中序遍历序列构造二叉树</title>
      <link>https://chrishrz.github.io/post/lc105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 10 May 2020 19:54:38 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题解 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 递归，先序的首字母是根节点，而中序的根节点区分左右子树，利用这个性质递</description>
    </item>
    
    <item>
      <title>[Lc]面试题07重建二叉树</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9807%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 10 May 2020 19:49:19 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9807%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 注意：本题与主站 105 题重复：(https://leetcode-cn.com/problems/construct-binary-tree</description>
    </item>
    
    <item>
      <title>[Lc]面试题06从尾到头打印链表</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9806%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 10 May 2020 17:46:46 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9806%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 题解 //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 1. 栈 从头到尾遍历链表，先取数入栈，再从栈中弹出放入数组 时间复杂度$O(n)$，遍历一次数组一次栈</description>
    </item>
    
    <item>
      <title>[Lc]面试题05替换空格</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9805%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</link>
      <pubDate>Sat, 09 May 2020 22:03:04 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9805%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</guid>
      <description>题目 题解 1. 双指针法 先统计空格个数，然后扩容，然后用双指针挨个从前往后复制数据，不需要额外空间 时间复杂度$O(n)$,遍历两遍 空间复杂度$O(</description>
    </item>
    
    <item>
      <title>[Lc]74搜索二维矩阵</title>
      <link>https://chrishrz.github.io/post/lc74%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Sat, 09 May 2020 21:27:34 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc74%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</guid>
      <description>题目 题解 稍微变形的二分查找，其实写法是一样的，主要就是在取mid的时候需要转化一下，开始取二分查找最初的left和right也要注意，还有二</description>
    </item>
    
    <item>
      <title>[Lc]240搜索二维矩阵II</title>
      <link>https://chrishrz.github.io/post/lc240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/</link>
      <pubDate>Sat, 09 May 2020 21:12:12 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/</guid>
      <description>题目 题解 可以一行一行的二分查找，但是比较慢，也没有利用这道题矩阵的性质 确定起点很重要，由于这道题矩阵的特殊形式，我们可以将起点定在右上（或者</description>
    </item>
    
    <item>
      <title>[Lc]面试题04二维数组中的查找</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9804%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sat, 09 May 2020 21:06:19 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9804%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</guid>
      <description>题目 240题 题解 可以一行一行的二分查找，但是比较慢，也没有利用这道题矩阵的性质 确定起点很重要，由于这道题矩阵的特殊形式，我们可以将起点定在右</description>
    </item>
    
    <item>
      <title>[Lc]面试题03数组中重复的数字</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9803%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Sat, 09 May 2020 17:53:52 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9803%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目 题解 1. 排序法（改变输入数组） 数组排序后找重复项 时间复杂度$O(nlog{n})$，主要是排序花费的 空间复杂度$O(1)$ class Solution {//三种方</description>
    </item>
    
    <item>
      <title>[Lc]70爬楼梯</title>
      <link>https://chrishrz.github.io/post/lc70%E7%88%AC%E6%A5%BC%E6%A2%AF/</link>
      <pubDate>Sat, 09 May 2020 13:27:32 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc70%E7%88%AC%E6%A5%BC%E6%A2%AF/</guid>
      <description>题目 题解 1. 动态规划（斐波那契数列递推公式） 其实就是斐波那契数列，可以用递推公式和通项公式求解 递推相当于动态规划，但是只和前两个数有关，所以不</description>
    </item>
    
    <item>
      <title>[Lc]204计数质数</title>
      <link>https://chrishrz.github.io/post/lc204%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</link>
      <pubDate>Sat, 09 May 2020 11:34:43 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc204%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</guid>
      <description>题目 题解 1. 暴力法 直接用暴力法会超时，时间复杂度$O(n^{2})$，因此使用暴力法要进行优化，即isPrime()函数只用遍历到sqrt(N</description>
    </item>
    
    <item>
      <title>[Lc]141环形链表</title>
      <link>https://chrishrz.github.io/post/lc141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 08 May 2020 21:12:47 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 链表定义： //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 题解 142的简化版，202的方法来源 1. 快慢指针法 时间复杂度$O(n)$ 空间复杂度$O(1)</description>
    </item>
    
    <item>
      <title>[Lc]202快乐数</title>
      <link>https://chrishrz.github.io/post/lc202%E5%BF%AB%E4%B9%90%E6%95%B0/</link>
      <pubDate>Fri, 08 May 2020 21:08:54 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc202%E5%BF%AB%E4%B9%90%E6%95%B0/</guid>
      <description>题目 题解 这题相当于142题的一个变形，相当于链表找环，但是不用找到起始点，判断是环就可以（这么说应该是141题） 1. set存值法 时间复杂度$O</description>
    </item>
    
    <item>
      <title>[Lc]142环形链表II</title>
      <link>https://chrishrz.github.io/post/lc142%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</link>
      <pubDate>Fri, 08 May 2020 20:48:24 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc142%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</guid>
      <description>题目 链表定义： //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 题解 141的进阶 1. 快慢指针法 设环长度为c，环前端长度为a，相遇点到环前端长度为y 快指针在一</description>
    </item>
    
    <item>
      <title>[Lc]172阶乘后的零</title>
      <link>https://chrishrz.github.io/post/lc172%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/</link>
      <pubDate>Fri, 08 May 2020 17:33:58 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc172%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/</guid>
      <description>题目 题解 这道题代码不难，关键是数学归纳。 如果把阶乘算出来再求0一定会超时，时间复杂度$O(n)$，pass。 这道题的关键是找2和5的个数，只</description>
    </item>
    
    <item>
      <title>[Lc]171Excel表列序号</title>
      <link>https://chrishrz.github.io/post/lc171excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/</link>
      <pubDate>Fri, 08 May 2020 17:08:51 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc171excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/</guid>
      <description>题目 题解 和168正好相反嘛 这题就简单多了，挨个取字母变成数字就可以了，注意有： 每次是乘26 每次要+1，和168的原因一样，这个是伪26进制，</description>
    </item>
    
    <item>
      <title>[Lc]168Excel表列名称</title>
      <link>https://chrishrz.github.io/post/lc168excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</link>
      <pubDate>Fri, 08 May 2020 16:07:04 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc168excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</guid>
      <description>题目 题解 和171相反的一个题嘛，这个稍微难一点。 这道题就是十进制转26进制，但是有一些需要注意的问题 首先不能从前往后插入数字，即先放最大位，</description>
    </item>
    
    <item>
      <title>[Lc]166分数到小数</title>
      <link>https://chrishrz.github.io/post/lc166%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/</link>
      <pubDate>Fri, 08 May 2020 12:30:44 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc166%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/</guid>
      <description>题目 题解 这道题其实就是模拟笔算除法的过程，挨个位产生商，主要判断是否除尽或者产生了循环。 class Solution { public: string fractionToDecimal(int numerator, int denominator) { string res; if(numerator==0) return &amp;quot;0&amp;quot;; //用异或判断是否为负</description>
    </item>
    
    <item>
      <title>[Lc]165比较版本号</title>
      <link>https://chrishrz.github.io/post/lc165%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/</link>
      <pubDate>Thu, 07 May 2020 20:25:09 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc165%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/</guid>
      <description>题目 题解 1. stringstream法 用stringstream和getline切割字符串，并挨个比较，本来想用getline的，但是这样wh</description>
    </item>
    
    <item>
      <title>[Lc]151翻转字符串里的单词</title>
      <link>https://chrishrz.github.io/post/lc151%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</link>
      <pubDate>Thu, 07 May 2020 19:33:04 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc151%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</guid>
      <description>题目 题解 1. 双旋转单擦除法 题目要求空间复杂度$O(1)$，该方法符合，即先整体翻转全部字符串，再逐个单词串翻转，空格跳过，不同单词之间的空格自</description>
    </item>
    
    <item>
      <title>Cpp字符串转数字总结</title>
      <link>https://chrishrz.github.io/post/cpp%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E5%AD%97%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 07 May 2020 17:11:15 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/cpp%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E5%AD%97%E6%80%BB%E7%BB%93/</guid>
      <description>c语言转换形式 string str; int i = atoi(str.c_str());//string转int float f = atof(str.c_str());//strin</description>
    </item>
    
    <item>
      <title>[Lc]93复原IP地址</title>
      <link>https://chrishrz.github.io/post/lc93%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80/</link>
      <pubDate>Thu, 07 May 2020 12:46:45 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc93%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80/</guid>
      <description>题目 题解 这道题主要是递归然后剪枝，符合条件的放入结果，不符合就键值，主要是要确定几种不符合条件的情况 剩下的数字不够分的，比如还有2个数，但是</description>
    </item>
    
    <item>
      <title>[Lc]91解码方法</title>
      <link>https://chrishrz.github.io/post/lc91%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 07 May 2020 11:13:52 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc91%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</guid>
      <description>题目 题解 这道题也是dp，但是不用数组保存过去的状态，经过分析讨论当前状态只与前两个状态有关，所以只用存前两个状态即可，共有四种情况，详解见I</description>
    </item>
    
    <item>
      <title>[Lc]125验证回文串</title>
      <link>https://chrishrz.github.io/post/lc125%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</link>
      <pubDate>Wed, 06 May 2020 21:55:59 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc125%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</guid>
      <description>题目 题解 双指针，挨个比较，注意的是跳过非数字字母，还有大写字母要转化成小写 时间复杂度$O(n)$ 空间复杂度$O(1)$ 七个重要的c++内置函</description>
    </item>
    
    <item>
      <title>[Lc]87扰乱字符串</title>
      <link>https://chrishrz.github.io/post/lc87%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Wed, 06 May 2020 16:47:56 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc87%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目 题解 1. 递归法 就是通过递归左右子串，首先判断长度是否相等，不相等直接false；然后判断是否完全一样，一样直接true；然后判断排序后是否</description>
    </item>
    
    <item>
      <title>[Lc]72编辑距离</title>
      <link>https://chrishrz.github.io/post/lc72%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</link>
      <pubDate>Wed, 06 May 2020 13:18:11 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc72%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</guid>
      <description>题目 题解 时间复杂度$O(mn)$ 空间复杂度$O(mn)$，都是搞dp数组用的 class Solution { public: int minDistance(string word1, string word2) { int n=word1.size(), m=word2.size(); if(n*m==0) return n+m;//若一个为空，返回另一个</description>
    </item>
    
    <item>
      <title>[Lc]68文本左右对齐</title>
      <link>https://chrishrz.github.io/post/lc68%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90/</link>
      <pubDate>Wed, 06 May 2020 11:28:45 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc68%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90/</guid>
      <description>题目 题解 时间复杂度$O(N)$ 空间复杂度$O(maxWidth+N)$，用于暂存每行的结果和存结果 class Solution { public: vector&amp;lt;string&amp;gt; fullJustify(vector&amp;lt;string&amp;gt;&amp;amp; words, int maxWidth) { vector&amp;lt;string&amp;gt; res; if(words.empty()) return res; int left = 0;/</description>
    </item>
    
    <item>
      <title>[Lc]71简化路径</title>
      <link>https://chrishrz.github.io/post/lc71%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Wed, 06 May 2020 10:22:56 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc71%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</guid>
      <description>题目 题解 时间复杂度$O(N)$，遍历path 空间复杂度$O(N)$，两个n，t暂存路径，res存结果 class Solution { public: string simplifyPath(string path) { string res, tmp; if(path.empty()) return res;//特</description>
    </item>
    
    <item>
      <title>[Lc]58最后一个单词的长度</title>
      <link>https://chrishrz.github.io/post/lc58%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Tue, 05 May 2020 21:43:53 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc58%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</guid>
      <description>题目 题解 时间复杂度$O(k)$, k为最后一个单词的长度。 空间复杂度$O(1)$ 从后往前遍历，开始的0全部跳过，然后计数，再次遇到0跳出循环 class</description>
    </item>
    
    <item>
      <title>MinGW使用to_string报错解决</title>
      <link>https://chrishrz.github.io/post/mingw%E4%BD%BF%E7%94%A8to_string%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Tue, 05 May 2020 18:31:02 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/mingw%E4%BD%BF%E7%94%A8to_string%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</guid>
      <description>在做leetcode49题时发现的错误，我是用clion对程序进行调试，报错，调试后发现是mingw中to_string的一个bug，在网上</description>
    </item>
    
    <item>
      <title>[Lc]49字母异位词分组</title>
      <link>https://chrishrz.github.io/post/lc49%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</link>
      <pubDate>Tue, 05 May 2020 12:59:21 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc49%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</guid>
      <description>题目 题解 1. unordered_map排序法 时间复杂度：排序的话算作$O(Klog{K})$,最外层的 for 循环，所以就是 $O(nKlog{K})</description>
    </item>
    
    <item>
      <title>[Lc]38外观数列</title>
      <link>https://chrishrz.github.io/post/lc38%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</link>
      <pubDate>Thu, 30 Apr 2020 21:11:40 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc38%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</guid>
      <description>题目 题解 时间复杂度$O(N*M)$ 空间复杂度$O(M_{end}+M_{end-1}) class Solution { public: string countAndSay(int n) { if(n == 0) return &amp;quot;&amp;quot;; string res = &amp;quot;1&amp;quo</description>
    </item>
    
    <item>
      <title>[Lc]1254统计封闭岛屿的数目</title>
      <link>https://chrishrz.github.io/post/lc1254%E7%BB%9F%E8%AE%A1%E5%B0%81%E9%97%AD%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E7%9B%AE/</link>
      <pubDate>Tue, 28 Apr 2020 11:49:31 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc1254%E7%BB%9F%E8%AE%A1%E5%B0%81%E9%97%AD%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E7%9B%AE/</guid>
      <description>题目 题解 1. DFS 时间复杂度$O(MN)$ 空间复杂度$O(1)$ class Solution { public: int dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid, int row, int column){ int rows = grid.size(); int columns = grid[0].size();//计算行列数 if(row</description>
    </item>
    
    <item>
      <title>[Lc]200岛屿数量</title>
      <link>https://chrishrz.github.io/post/lc200%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</link>
      <pubDate>Mon, 27 Apr 2020 17:05:33 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc200%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</guid>
      <description>题目 题解 1. DFS 时间复杂度$O(N*M)$ 空间复杂度$O(N*M)$（最坏情况） class Solution { public: void dfs(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid, int row, int column){ int rows = grid.size(); int columns = grid[0].size()</description>
    </item>
    
    <item>
      <title>[Lc]面试题40最小的k个数</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9840%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Mon, 27 Apr 2020 15:32:13 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9840%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</guid>
      <description>题目 题解 1. 堆法 时间复杂度：$O(n\log k)$，其中 nn 是数组 arr 的长度。由于大根堆实时维护前 k 小值，所以插入删除都是 $O(\log k)$ 的时间复杂度，最坏情</description>
    </item>
    
    <item>
      <title>[Lc]84柱状图中最大的矩形</title>
      <link>https://chrishrz.github.io/post/lc84%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</link>
      <pubDate>Sun, 26 Apr 2020 13:23:35 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc84%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</guid>
      <description>题目 题解 1. 双数组法 时间复杂度$O(N)$ 空间复杂度$O(N)$ class Solution { public: int largestRectangleArea(vector&amp;lt;int&amp;gt;&amp;amp; heights) {//多种方法，可以暴力搜索，但会超时，这里用时间复杂度较低的方</description>
    </item>
    
    <item>
      <title>[Lc]28实现strStr()</title>
      <link>https://chrishrz.github.io/post/lc28%E5%AE%9E%E7%8E%B0strstr/</link>
      <pubDate>Fri, 24 Apr 2020 21:26:38 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc28%E5%AE%9E%E7%8E%B0strstr/</guid>
      <description>题目 题解 这道题说是简单题结果花了我两天，BF算法的确简单，但是其他的字符串匹配算法真的太复杂了。。。 1. 正则表达式 这个在leetcode上超时</description>
    </item>
    
    <item>
      <title>十大排序算法的数组和链表实现</title>
      <link>https://chrishrz.github.io/post/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 22 Apr 2020 16:40:07 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0/</guid>
      <description>数组排序在牛客,进行测试；链表排序在leetcode进行测试。 发现一个牛逼的数据结构与算法的可视化网站(https://visualgo.n</description>
    </item>
    
    <item>
      <title>[Lc]22括号生成</title>
      <link>https://chrishrz.github.io/post/lc22%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</link>
      <pubDate>Tue, 21 Apr 2020 12:27:02 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc22%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</guid>
      <description>题目 题解 1.递归法 class Solution { vector&amp;lt;string&amp;gt; res;//在私有变量定义res在存结果， public: vector&amp;lt;string&amp;gt; generateParenthesis(int n) {//两种方法。1.递归 if(n==0) return res;//特殊情况 generateParenthesisDFS(n, n, &amp;quot;</description>
    </item>
    
    <item>
      <title>[Lc]20有效的括号</title>
      <link>https://chrishrz.github.io/post/lc20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Tue, 21 Apr 2020 11:49:21 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</guid>
      <description>题目 题解 时间复杂度$O(N)$ 空间复杂度$O(N)$ class Solution { public: bool isValid(string s) {//用栈 //不能挨个比较，因为有可能两个括号是交错的，用栈最合适 stack&amp;lt;char&amp;gt; par</description>
    </item>
    
    <item>
      <title>[Lc]17电话号码的字母组合</title>
      <link>https://chrishrz.github.io/post/lc17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</link>
      <pubDate>Mon, 20 Apr 2020 20:25:18 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</guid>
      <description>题目 题解 时间复杂度$O(3^{N}+4^{M})$，N是有三个字母的数字数量，M是有4个字母的数字数量。 空间复杂度$O(3^{N}+4^{M</description>
    </item>
    
    <item>
      <title>[Lc]14最长公共前缀</title>
      <link>https://chrishrz.github.io/post/lc14%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</link>
      <pubDate>Sat, 18 Apr 2020 21:01:06 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc14%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</guid>
      <description>题目 题解 1. 遍历法 时间复杂度$O(S)$（最坏情况）。S是所有字符数量。 空间复杂度$O(1)$ class Solution { public: string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) {//两种方法。1.遍历法 //这道</description>
    </item>
    
    <item>
      <title>Cpp数组初始化问题(待续）</title>
      <link>https://chrishrz.github.io/post/cpp%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 18 Apr 2020 12:47:18 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/cpp%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</guid>
      <description>数组 c++数组主要包括静态数组，动态数组，vector 1. 静态数组 未初始化的数组是随机数据，初始化方法有 int arr[1024] = {0}; //全部初始化为0 int arr[1024] = {1}; //</description>
    </item>
    
    <item>
      <title>牛客oj的输入输出</title>
      <link>https://chrishrz.github.io/post/%E7%89%9B%E5%AE%A2oj%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</link>
      <pubDate>Wed, 15 Apr 2020 18:52:22 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/%E7%89%9B%E5%AE%A2oj%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</guid>
      <description></description>
    </item>
    
    <item>
      <title>[Lc]67二进制求和</title>
      <link>https://chrishrz.github.io/post/lc67%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</link>
      <pubDate>Mon, 13 Apr 2020 22:36:11 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc67%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</guid>
      <description>题目 题解 按位相加即可，注意字符串与整型的转换，数字小的填0，注意进位 时间复杂度$O(max{(aLen + bLen)})$ 空间复杂度$O(max{(aLen</description>
    </item>
    
    <item>
      <title>[Lc]31下一个排列</title>
      <link>https://chrishrz.github.io/post/lc31%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</link>
      <pubDate>Sun, 12 Apr 2020 00:34:19 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc31%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</guid>
      <description>题目 题解 这道题不好理解，具体的题解见leetcode和Grandyang class Solution {//这道题不好理解，最好直接记方法 public: void nextPermutation(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(), i = n-2, j =</description>
    </item>
    
    <item>
      <title>[Lc]60第k个排列</title>
      <link>https://chrishrz.github.io/post/lc60%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97/</link>
      <pubDate>Sat, 11 Apr 2020 22:55:04 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc60%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97/</guid>
      <description>题目 题解 这道题直接找规律，比较难自己想通，该解法出自grandyang class Solution { public: string getPermutation(int n, int k) { string res;//定义res保存结果 string nums = &amp;quot;</description>
    </item>
    
    <item>
      <title>[Lc]69x的平方根</title>
      <link>https://chrishrz.github.io/post/lc69x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</link>
      <pubDate>Sat, 11 Apr 2020 22:55:04 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc69x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</guid>
      <description>题目 题解 1. 二分查找法 时间复杂度$o(log{N})$ 空间复杂度$O(1)$ class Solution { public: int mySqrt(int x) {//两个方法。1、二分查找法 if (x &amp;lt;= 1) return x;//0和</description>
    </item>
    
    <item>
      <title>[Lc]50Pow(x,n)</title>
      <link>https://chrishrz.github.io/post/lc50powxn/</link>
      <pubDate>Sat, 11 Apr 2020 22:04:52 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc50powxn/</guid>
      <description>题目 题解 快速幂是指x**2n == x**n + x**n，利用这一性质，不断的一半的数进行运算。有递归法和迭代法两种，注意要区分n为奇偶和n为负数的情况。</description>
    </item>
    
    <item>
      <title>[Lc]43字符串相乘</title>
      <link>https://chrishrz.github.io/post/lc43%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</link>
      <pubDate>Sat, 11 Apr 2020 13:36:02 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc43%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</guid>
      <description>题目 题解 时间复杂度$O(mn)$ 空间复杂度$O(m+n)$ class Solution { public: string multiply(string num1, string num2) { string res = &amp;quot;&amp;quot;;//初始化结果res int len1 = num1.size(), len2</description>
    </item>
    
    <item>
      <title>面经总结</title>
      <link>https://chrishrz.github.io/post/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 11 Apr 2020 12:06:16 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</guid>
      <description>记录最近参加的面试的题目 腾讯春招实习提前批（客户端开发） 一面 二叉树的最大直径，编程题 链表的排序，要求时间复杂度$O(Nlog(N))$,空间</description>
    </item>
    
    <item>
      <title>[Lc]29两数相除</title>
      <link>https://chrishrz.github.io/post/lc29%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</link>
      <pubDate>Fri, 10 Apr 2020 22:46:20 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc29%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</guid>
      <description>题目 题解 这道题太恶心了，溢出搞得我头疼，先记录一个答案，来自这里,作者：cglin-2 这道题目要求不使用乘法、除法和 mod 运算符，且假设环境只能</description>
    </item>
    
    <item>
      <title>[Lc]12整数转罗马数字</title>
      <link>https://chrishrz.github.io/post/lc12%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 10 Apr 2020 00:13:43 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc12%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</guid>
      <description>题目 题解 1. 分类法 每个数量级可以分为4类，1~3，4，5~8，9。因此就使用每个数量级取商然后选择合适的类别进行表达，余数进行下一个数量级商的</description>
    </item>
    
    <item>
      <title>[Lc]222完全二叉树的节点个数</title>
      <link>https://chrishrz.github.io/post/lc222%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Thu, 09 Apr 2020 11:03:58 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc222%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 class Solution { public: int countNodes(TreeNode* root) {//1.递归直接统计节点数 return root? 1+countNodes(root-&amp;gt;left)+countNodes(root-&amp;gt;right) : 0; } }; 2. 利用</description>
    </item>
    
    <item>
      <title>[Lc]226翻转二叉树</title>
      <link>https://chrishrz.github.io/post/lc226%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Wed, 08 Apr 2020 22:48:38 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc226%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 class Solution {//两种方法。1、递归法 public: TreeNode* invertTree(TreeNode* root) { if(!root) return nullptr;/</description>
    </item>
    
    <item>
      <title>[Lc]199二叉树的右视图</title>
      <link>https://chrishrz.github.io/post/lc199%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Wed, 08 Apr 2020 22:14:18 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc199%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; //本题借鉴#102层次遍历 class Solution { public: vector&amp;lt;int&amp;gt; rightSideView(TreeNode* root) { vector&amp;lt;int&amp;gt; res; if(!root) return res; queue&amp;lt;TreeNode*&amp;gt; q{{root}}; while(!q.empty()){ res.p</description>
    </item>
    
    <item>
      <title>[Lc]173二叉搜索树迭代器</title>
      <link>https://chrishrz.github.io/post/lc173%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Wed, 08 Apr 2020 18:20:18 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc173%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; //这道题就是写一个中序遍历，因为题目提到是搜索二叉树 class BSTIterator { stack&amp;lt;TreeNode*&amp;gt; s;//</description>
    </item>
    
    <item>
      <title>[Lc]129求根到叶子节点数字之和</title>
      <link>https://chrishrz.github.io/post/lc129%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Wed, 08 Apr 2020 13:24:46 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc129%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1.递归法 class Solution { public: int sumNumbers(TreeNode* root) {//两种方法。1.递归法 return DFSsunNum</description>
    </item>
    
    <item>
      <title>[Lc]117填充每个节点的下一个右侧节点指针II</title>
      <link>https://chrishrz.github.io/post/lc117%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88ii/</link>
      <pubDate>Wed, 08 Apr 2020 11:41:56 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc117%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88ii/</guid>
      <description>题目 题解 该题二叉树结构如下： // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; 1.递归法 //和#</description>
    </item>
    
    <item>
      <title>[Lc]116填充每个节点的下一个右侧节点指针</title>
      <link>https://chrishrz.github.io/post/lc116%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</link>
      <pubDate>Tue, 07 Apr 2020 22:15:10 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc116%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</guid>
      <description>题目 题解 该题二叉树结构如下： // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; 1. 递归法 //这道题</description>
    </item>
    
    <item>
      <title>[Lc]114二叉树展开为链表</title>
      <link>https://chrishrz.github.io/post/lc114%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 07 Apr 2020 20:12:38 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc114%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 先序递归法 //本题的顺序可以看出是先序遍历。 class Solution {//两种方法。1、</description>
    </item>
    
    <item>
      <title>[转载]计算机考研大纲2019</title>
      <link>https://chrishrz.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%A7%E7%BA%B22019/</link>
      <pubDate>Sat, 28 Mar 2020 17:46:39 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%A7%E7%BA%B22019/</guid>
      <description>2019年计算机408的考试大纲。 转自https://kaoyan.eol.cn/nnews/201809/t20180915_162519</description>
    </item>
    
    <item>
      <title>计算机网络学习笔记（待续。。。）</title>
      <link>https://chrishrz.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 28 Mar 2020 17:33:57 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>这个主要来自谢希仁的《计算机网络》和网络课程，先记重点。 部分图和概念摘自菜鸟教程,侵删。 菜鸟教程的原文链接是这个:http://www.cn</description>
    </item>
    
    <item>
      <title>[Lc]113路径总和2</title>
      <link>https://chrishrz.github.io/post/lc113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C2/</link>
      <pubDate>Fri, 27 Mar 2020 22:34:03 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C2/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 时间复杂度：$O(N)$ 空间复杂度：$O(N)$ 需要额外空间。</description>
    </item>
    
    <item>
      <title>阿勒泰之春</title>
      <link>https://chrishrz.github.io/post/%E9%98%BF%E5%8B%92%E6%B3%B0%E4%B9%8B%E6%98%A5/</link>
      <pubDate>Sun, 22 Mar 2020 16:57:16 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/%E9%98%BF%E5%8B%92%E6%B3%B0%E4%B9%8B%E6%98%A5/</guid>
      <description>阿勒泰市北部为阿尔泰山地，南部为额尔齐斯河支流克兰河流域平原。 阿勒泰市属温带半干旱气候。四季分明，日照充足。冬长严寒，夏季温热，春秋短暂。1</description>
    </item>
    
    <item>
      <title>[Lc]112路径总和</title>
      <link>https://chrishrz.github.io/post/lc112%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</link>
      <pubDate>Fri, 20 Mar 2020 20:06:36 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc112%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 时间复杂度: 最坏情况$O(N)$ 空间复杂度: 最坏情况$O(N)</description>
    </item>
    
    <item>
      <title>[Lc]111二叉树的最小深度</title>
      <link>https://chrishrz.github.io/post/lc111%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Wed, 18 Mar 2020 17:10:27 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc111%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 时间复杂度: $O(N)$ 空间复杂度: 最坏情况下，整棵树是非平衡的，例如每</description>
    </item>
    
    <item>
      <title>[Lc]110平衡二叉树</title>
      <link>https://chrishrz.github.io/post/lc110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 17 Mar 2020 16:32:45 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 时间复杂度: $O(n\log n)$ 空间复杂度: $O(n)$ class Solution { public: bool isBalanced(TreeNode* root) {//两种方法。1</description>
    </item>
    
    <item>
      <title>[Lc]107二叉树的层次遍历2</title>
      <link>https://chrishrz.github.io/post/lc174%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%862/</link>
      <pubDate>Tue, 17 Mar 2020 14:01:58 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc174%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%862/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 递归法有两种思路,一种直接翻转最终数组,一种在插入时就改变顺序</description>
    </item>
    
    <item>
      <title>[Lc]104二叉树的最大深度</title>
      <link>https://chrishrz.github.io/post/lc104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Tue, 17 Mar 2020 13:12:19 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 时间复杂度: $O(N)$ 空间复杂度: $O(N)$ class Solution {//这个题就是遍历然后存最大</description>
    </item>
    
    <item>
      <title>[Lc]103二叉树的锯齿层次遍历</title>
      <link>https://chrishrz.github.io/post/lc103%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</link>
      <pubDate>Tue, 17 Mar 2020 11:48:54 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc103%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1.迭代法 class Solution {//和#102类似，有所改变，有迭代法和递归法两种方法</description>
    </item>
    
    <item>
      <title>[转载]在hugo中使用mathjax</title>
      <link>https://chrishrz.github.io/post/%E8%BD%AC%E8%BD%BD%E5%9C%A8hugo%E4%B8%AD%E4%BD%BF%E7%94%A8mathjax/</link>
      <pubDate>Mon, 16 Mar 2020 19:47:24 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/%E8%BD%AC%E8%BD%BD%E5%9C%A8hugo%E4%B8%AD%E4%BD%BF%E7%94%A8mathjax/</guid>
      <description>在Hugo中使用MathJax 在博客中写公式中想直接使用latex,找了一圈发现hugo本身是不支持的,查阅到匿蟒前辈写的一篇博客,详细介绍</description>
    </item>
    
    <item>
      <title>[Lc]102二叉树的层次遍历</title>
      <link>https://chrishrz.github.io/post/lc102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sun, 15 Mar 2020 15:03:26 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</guid>
      <description>题解 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 队列迭代法 class Solution {//两种方法。1、队列迭代法。 public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; if(!root) return res; /</description>
    </item>
    
    <item>
      <title>[Lc]101对称二叉树</title>
      <link>https://chrishrz.github.io/post/lc101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sat, 14 Mar 2020 19:54:18 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题解 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 class Solution {//三种方法。1、递归法。有点像#100 public: bool isSymmetric(TreeNode* root) { if(!root) return t</description>
    </item>
    
    <item>
      <title>[Lc]100相同的树</title>
      <link>https://chrishrz.github.io/post/lc100%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</link>
      <pubDate>Sat, 14 Mar 2020 19:27:58 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc100%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</guid>
      <description>题目 题解 这道题就是遍历。这里写一个先序遍历，其他遍历方式见相应例题。 二叉树的遍历包括DFS(深度优先搜索)的先序遍历、中序遍历、后序遍历。 还</description>
    </item>
    
    <item>
      <title>[Lc]98验证二叉搜索树</title>
      <link>https://chrishrz.github.io/post/lc98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sat, 14 Mar 2020 13:53:22 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题目 题解 TreeNode的定义： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ 1. 直接递归法 class Solution {//三种方法。1、直接递归</description>
    </item>
    
    <item>
      <title>[Lc]95不同的二叉搜索树2</title>
      <link>https://chrishrz.github.io/post/lc95%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</link>
      <pubDate>Sat, 14 Mar 2020 00:59:26 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc95%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</guid>
      <description>题目 题解 定义二叉树: //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; 1. 递归法 class Solution {//#96的升级版。两种方法。1、递归 public: vector&amp;lt;TreeNode*&amp;gt; generateTrees(int n) { vector&amp;lt;TreeNode*&amp;gt; ans; if(n==0) return a</description>
    </item>
    
    <item>
      <title>[转载]在hugo中添加mermaid支持</title>
      <link>https://chrishrz.github.io/post/%E8%BD%AC%E8%BD%BD%E5%9C%A8hugo%E4%B8%AD%E6%B7%BB%E5%8A%A0mermaid%E6%94%AF%E6%8C%81/</link>
      <pubDate>Fri, 13 Mar 2020 17:39:04 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/%E8%BD%AC%E8%BD%BD%E5%9C%A8hugo%E4%B8%AD%E6%B7%BB%E5%8A%A0mermaid%E6%94%AF%E6%8C%81/</guid>
      <description>在markdown中拓展mermaid 前面用有道云笔记的markdown功能，发现他画流程图非常好用。就想把这个功能加入到自己的blog中。</description>
    </item>
    
    <item>
      <title>[Lc]96不同的二叉搜索树</title>
      <link>https://chrishrz.github.io/post/lc96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Fri, 13 Mar 2020 12:26:13 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题目 题解 这道题是#95的简化版。#95要求写出所有的二叉搜索树，这道题只要求写出二叉搜索树的个数，因此要简单一点，其结题思路与卡塔兰数有关。</description>
    </item>
    
    <item>
      <title>C&#43;&#43;哈希表unordered_map的常见方法小结</title>
      <link>https://chrishrz.github.io/post/c&#43;&#43;%E5%93%88%E5%B8%8C%E8%A1%A8unordered_map%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93/</link>
      <pubDate>Thu, 12 Mar 2020 22:34:40 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/c&#43;&#43;%E5%93%88%E5%B8%8C%E8%A1%A8unordered_map%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93/</guid>
      <description>unordered_map的常见用法 unordered_map &amp;lt;string,int&amp;gt; res; res.empty();//判断是否为空 res.size();//计算res的大小 res[&amp;quot;{key}&amp;quot;]; res.at(</description>
    </item>
    
    <item>
      <title>设置vscode的终端为cmder</title>
      <link>https://chrishrz.github.io/post/%E8%AE%BE%E7%BD%AEvscode%E7%9A%84%E7%BB%88%E7%AB%AF%E4%B8%BAcmder/</link>
      <pubDate>Thu, 12 Mar 2020 13:51:37 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/%E8%AE%BE%E7%BD%AEvscode%E7%9A%84%E7%BB%88%E7%AB%AF%E4%B8%BAcmder/</guid>
      <description>流程 1. 进入setting(ctrl+shift+p) 2. 依次进入User-&amp;gt;Features-&amp;gt;Terminal 3. 进入上图所示的E</description>
    </item>
    
    <item>
      <title>[Lc]94/144/145二叉树的三种遍历</title>
      <link>https://chrishrz.github.io/post/lc94_144_145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 09 Mar 2020 11:28:56 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc94_144_145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/</guid>
      <description>题目 二叉树的遍历 简单地理解，满足以下两个条件的树就是二叉树： 本身是有序树； 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2； 下图即一颗</description>
    </item>
    
    <item>
      <title>序</title>
      <link>https://chrishrz.github.io/post/first/</link>
      <pubDate>Mon, 09 Mar 2020 11:28:56 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/first/</guid>
      <description>ChrisHRZ的第一篇个人博客 写在前面 折腾了一天，终于搭建出来个人博客的雏形，过程还是挺有意思的。也算有了一片自己的领地。今天就这样了，后</description>
    </item>
    
  </channel>
</rss>