<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>[lc]#117Populating_Next_Right_Pointers_in_Each_Node2 - Focus-ChrisHRZ&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="ChrisHRZ" /><meta name="description" content="题目 Given a binary tree struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Follow up: You may only use constant extra space. Recursive approach is fine, you may assume implicit stack" /><meta name="keywords" content="code, life, study" />






<meta name="generator" content="Hugo 0.66.0 with theme even" />


<link rel="canonical" href="https://chrishrz.github.io/post/lct117populating_next_right_pointers_in_each_node2/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">


<meta property="og:title" content="[lc]#117Populating_Next_Right_Pointers_in_Each_Node2" />
<meta property="og:description" content="题目 Given a binary tree struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Follow up: You may only use constant extra space. Recursive approach is fine, you may assume implicit stack" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chrishrz.github.io/post/lct117populating_next_right_pointers_in_each_node2/" />
<meta property="article:published_time" content="2020-04-08T11:41:56+08:00" />
<meta property="article:modified_time" content="2020-04-08T11:41:56+08:00" />
<meta itemprop="name" content="[lc]#117Populating_Next_Right_Pointers_in_Each_Node2">
<meta itemprop="description" content="题目 Given a binary tree struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Follow up: You may only use constant extra space. Recursive approach is fine, you may assume implicit stack">
<meta itemprop="datePublished" content="2020-04-08T11:41:56&#43;08:00" />
<meta itemprop="dateModified" content="2020-04-08T11:41:56&#43;08:00" />
<meta itemprop="wordCount" content="995">



<meta itemprop="keywords" content="Tree,Binary tree," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[lc]#117Populating_Next_Right_Pointers_in_Each_Node2"/>
<meta name="twitter:description" content="题目 Given a binary tree struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Follow up: You may only use constant extra space. Recursive approach is fine, you may assume implicit stack"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>


<meta name="baidu-site-verification" content="GDMA35xQfM" />
<meta name="google-site-verification" content="f-5-S53Hm0WIn0Tnfu-dg0sNmCZeahUFILgUSI9JLQA" />
<meta name="baidu-site-verification" content="74mXju2aOk" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">FOCUS</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">FOCUS</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>



    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">[lc]#117Populating_Next_Right_Pointers_in_Each_Node2</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-04-08 </span>
        <div class="post-category">
            <a href="/categories/leetcode/"> leetcode </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#题目">题目</a></li>
    <li><a href="#题解">题解</a>
      <ul>
        <li><a href="#1递归法">1.递归法</a></li>
        <li><a href="#2-队列递归法">2. 队列递归法</a></li>
        <li><a href="#3-三指针法">3. 三指针法</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="题目">题目</h2>
<p>Given a binary tree</p>
<p>struct Node {
int val;
Node *left;
Node *right;
Node *next;
}
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p> </p>
<p><strong>Follow up:</strong></p>
<p>You may only use constant extra space.
Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.
 </p>
<p><strong>Example 1:</strong>
<img src="/img/img2020-04-08-11-43-23.png" alt="">
<strong>Input:</strong> root = [1,2,3,4,5,null,7]<br>
<strong>Output:</strong>[1,#,2,3,#,4,5,7,#]<br>
<strong>Explanation:</strong> Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &lsquo;#&rsquo; signifying the end of each level.
 </p>
<p>Constraints:</p>
<ul>
<li>The number of nodes in the given tree is less than 6000.</li>
<li>100 &lt;= node.val &lt;= 100</li>
</ul>
<h2 id="题解">题解</h2>
<p>该题二叉树结构如下：</p>
<pre><code class="language-cpp">// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
</code></pre>
<h3 id="1递归法">1.递归法</h3>
<pre><code class="language-cpp">//和#116类似
class Solution {//三种方法。1、递归法(#116的升级版)
public:
    Node* connect(Node* root) {
        if(!root) return nullptr;//特殊情况
//主要区别
        Node *p = root-&gt;next;//p指向root的next，
        while(p){
            if(p-&gt;left){
                p = p-&gt;left;
                break;
            }
            if(p-&gt;right){
                p = p-&gt;right;
                break;
            }
            p = p-&gt;next;
        }//这一部分用于找该子节点的next，若父节点的左子树或右子树存在，则next为该子树，否则一直遍历到nullptr
        if(root-&gt;right) root-&gt;right-&gt;next = p;//右子树指向上面找到的节点
        if(root-&gt;left) root-&gt;left-&gt;next = root-&gt;right? root-&gt;right : p;//若右子树不存在，则指向p，否则指向右子节点
//主要区别
        connect(root-&gt;right);
        connect(root-&gt;left);//注意这里要先右后左
        return root;
    }
};
</code></pre>
<h3 id="2-队列递归法">2. 队列递归法</h3>
<pre><code class="language-cpp">//和#116类似
class Solution {//三种方法。2、队列迭代法(和#116完全一样，细节见#116)
public:
    Node* connect(Node* root) {
        if(!root) return nullptr;//特殊情况
        queue&lt;Node*&gt; q;//建立队列
        q.push(root);//将根节点压入队列
        while(!q.empty()){//当队列不为空，继续迭代
            for(int i=q.size(); i&gt;0; i--){//对当前行处理，细节见#102
                auto tmp = q.front();q.pop();
                if(i&gt;1) tmp-&gt;next = q.front();//与#102主要区别1，除了最后一个数外其他节点指向队首
                if(tmp-&gt;left) q.push(tmp-&gt;left);
                if(tmp-&gt;right) q.push(tmp-&gt;right); //这与#102一样
            }
        }
        return root;
    }
};
</code></pre>
<blockquote>
<p>上述两种方法时间/空间复杂度为$O(N)$,题目要求可以用常数空间复杂度，下面这个方法使用常数复杂度。</p>
</blockquote>
<h3 id="3-三指针法">3. 三指针法</h3>
<pre><code class="language-cpp">class Solution {//三种方法。3、三指针法(#116的升级版)
public:
    Node* connect(Node* root) {
        Node* Dummy = new Node(0,nullptr,nullptr,nullptr);
        //哑节点可以解决没有最左子树的问题
        Node *cur = Dummy, *father = root;
        //两个指针，一个用来遍历子层，一个用来遍历父层
        while(father){//当父层遍历未结束
            if(father-&gt;left){
                cur-&gt;next = father-&gt;left;
                cur = cur-&gt;next;
            }//若该父节点左子树存在，则子层cur指向该子树
            if(father-&gt;right){
                cur-&gt;next = father-&gt;right;
                cur = cur-&gt;next;
            }//右子树同上
            father = father-&gt;next;//遍历下一个父节点
            if(!father){
                cur = Dummy;
                father = cur-&gt;next;
                Dummy-&gt;next = nullptr;
            }//父层遍历结束，cur返回哑节点，父层指针回到子层最左，哑节点断开
        }
        return root;
    }
};
</code></pre>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">ChrisHRZ</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2020-04-08
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/tree/">Tree</a>
          <a href="/tags/binary-tree/">Binary tree</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/lct129sum_root_to_leaf_numbers/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">[lc]#129Sum_Root_to_Leaf_Numbers</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/lct116populating_next_right_pointers_in_each_node/">
            <span class="next-text nav-default">[lc]#116Populating_Next_Right_Pointers_in_Each_Node</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  <span id="/post/lct117populating_next_right_pointers_in_each_node2/" class="leancloud_visitors" data-flag-title="[lc]#117Populating_Next_Right_Pointers_in_Each_Node2">
		<span class="post-meta-item-text">文章阅读量 </span>
		<span class="leancloud-visitors-count">0</span>
		<p></p>
	  </span>
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'M8Fyr1YXIu2Ov8Wh4ByqtEzq-gzGzoHsz',
        appKey: 'AHiPSGeLQbvrQGQ6KfhvOKvN',
        notify:  false ,
        verify:  false ,
        avatar:'mm',
        placeholder: '说点什么吧...',
        visitor:  true 
    });
  </script>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://github.com/ChrisHRZ" class="iconfont icon-github" title="github"></a>
  <a href="https://chrishrz.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">ChrisHRZ</span>
  </span>
</div>


<script src="https://cdn.bootcss.com/mermaid/8.4.8/mermaid.min.js"></script>

<script src="https://cdn.bootcss.com/mathjax/2.7.7/MathJax.js"></script>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>








</body>
</html>
