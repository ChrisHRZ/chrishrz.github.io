<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>[lc]#116Populating_Next_Right_Pointers_in_Each_Node - Focus-ChrisHRZ&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="ChrisHRZ" /><meta name="description" content="题目 You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all" /><meta name="keywords" content="code, life, study" />






<meta name="generator" content="Hugo 0.66.0 with theme even" />


<link rel="canonical" href="https://chrishrz.github.io/post/lct116populating_next_right_pointers_in_each_node/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">


<meta property="og:title" content="[lc]#116Populating_Next_Right_Pointers_in_Each_Node" />
<meta property="og:description" content="题目 You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chrishrz.github.io/post/lct116populating_next_right_pointers_in_each_node/" />
<meta property="article:published_time" content="2020-04-07T22:15:10+08:00" />
<meta property="article:modified_time" content="2020-04-07T22:15:10+08:00" />
<meta itemprop="name" content="[lc]#116Populating_Next_Right_Pointers_in_Each_Node">
<meta itemprop="description" content="题目 You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all">
<meta itemprop="datePublished" content="2020-04-07T22:15:10&#43;08:00" />
<meta itemprop="dateModified" content="2020-04-07T22:15:10&#43;08:00" />
<meta itemprop="wordCount" content="997">



<meta itemprop="keywords" content="Tree,Binary tree," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[lc]#116Populating_Next_Right_Pointers_in_Each_Node"/>
<meta name="twitter:description" content="题目 You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>


<meta name="baidu-site-verification" content="GDMA35xQfM" />
<meta name="google-site-verification" content="f-5-S53Hm0WIn0Tnfu-dg0sNmCZeahUFILgUSI9JLQA" />
<meta name="baidu-site-verification" content="74mXju2aOk" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">FOCUS</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">FOCUS</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>



    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">[lc]#116Populating_Next_Right_Pointers_in_Each_Node</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-04-07 </span>
        <div class="post-category">
            <a href="/categories/leetcode/"> leetcode </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#题目">题目</a></li>
    <li><a href="#题解">题解</a>
      <ul>
        <li><a href="#1-递归法">1. 递归法</a></li>
        <li><a href="#2-队列递归法">2. 队列递归法</a></li>
        <li><a href="#3-双指针法">3. 双指针法</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="题目">题目</h2>
<p>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<pre><code>struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
</code></pre>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p> </p>
<p><strong>Follow up:</strong></p>
<p>You may only use constant extra space.
Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.
 </p>
<p><strong>Example 1:</strong>
<img src="/img/img2020-04-07-22-19-39.png" alt="">
<strong>Input</strong>: root = [1,2,3,4,5,6,7]<br>
<strong>Output</strong>: [1,#,2,3,#,4,5,6,7,#]<br>
<strong>Explanation</strong>: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &lsquo;#&rsquo; signifying the end of each level.</p>
<h2 id="题解">题解</h2>
<p>该题二叉树结构如下：</p>
<pre><code class="language-cpp">// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
</code></pre>
<h3 id="1-递归法">1. 递归法</h3>
<pre><code class="language-cpp">//这道题是#102层次遍历的应用
class Solution {//三种方法。1、递归法
//严格来说这个递归法与#102的不一样，应该是用的先序遍历的递归思想
public:
    Node* connect(Node* root) {
        if(!root) return nullptr;//特殊情况
        if(root-&gt;left) root-&gt;left-&gt;next = root-&gt;right;
        //因为是完全二叉树，若左子节点存在，则其next指向右子节点
        if(root-&gt;right) root-&gt;right-&gt;next = root-&gt;next? root-&gt;next-&gt;left : nullptr;
        //若右子节点存在，则若该节点next有值，则指向next的左子节点，否则指向空
        connect(root-&gt;left);
        connect(root-&gt;right);//按先序遍历顺序递归左右子树
        return root;
    }
};
</code></pre>
<h3 id="2-队列递归法">2. 队列递归法</h3>
<pre><code class="language-cpp">//这道题是#102层次遍历的应用
class Solution {//三种方法。2、队列迭代法
public:
    Node* connect(Node* root) {
        if(!root) return nullptr;//特殊情况
        queue&lt;Node*&gt; q;//建立队列
        q.push(root);//将根节点压入队列
        while(!q.empty()){//当队列不为空，继续迭代
            for(int i=q.size(); i&gt;0; i--){//对当前行处理，细节见#102
                auto tmp = q.front();q.pop();
                if(i&gt;1) tmp-&gt;next = q.front();//与#102主要区别1，除了最后一个数外其他节点指向队首
                if(tmp-&gt;left) q.push(tmp-&gt;left);
                if(tmp-&gt;right) q.push(tmp-&gt;right); //这与#102一样
            }
        }
        return root;
    }
};
</code></pre>
<h3 id="3-双指针法">3. 双指针法</h3>
<pre><code class="language-cpp">//这道题是#102层次遍历的应用
class Solution {//三种方法。3、双指针法
public:
    Node* connect(Node* root) {
        if(!root) return nullptr;//特殊情况
        Node *start = root, *cur = nullptr;//初始化两个指针
        while(start-&gt;left){//当start指针的左子树存在，继续迭代
            cur = start;//设置cur指向start
            while(cur){//当cur存在，说明这一层还没迭代完，继续迭代
                cur-&gt;left-&gt;next = cur-&gt;right;//cur的左子树指向右子树
                if(cur-&gt;next) cur-&gt;right-&gt;next = cur-&gt;next-&gt;left;//若cur-&gt;next存在,则其右子树指向cur-&gt;next的左子树
                cur = cur-&gt;next;//cur指向下个节点
            }
            start = start-&gt;left;//start指向start的左子树
        }
        return root;
    }
};
</code></pre>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">ChrisHRZ</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2020-04-07
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/tree/">Tree</a>
          <a href="/tags/binary-tree/">Binary tree</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/lct117populating_next_right_pointers_in_each_node2/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">[lc]#117Populating_Next_Right_Pointers_in_Each_Node2</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/lct114flatten_binary_tree_to_linkedlist/">
            <span class="next-text nav-default">[lc]#114Flatten_Binary_Tree_to_LinkedList</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  <span id="/post/lct116populating_next_right_pointers_in_each_node/" class="leancloud_visitors" data-flag-title="[lc]#116Populating_Next_Right_Pointers_in_Each_Node">
		<span class="post-meta-item-text">文章阅读量 </span>
		<span class="leancloud-visitors-count">0</span>
		<p></p>
	  </span>
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'M8Fyr1YXIu2Ov8Wh4ByqtEzq-gzGzoHsz',
        appKey: 'AHiPSGeLQbvrQGQ6KfhvOKvN',
        notify:  false ,
        verify:  false ,
        avatar:'mm',
        placeholder: '说点什么吧...',
        visitor:  true 
    });
  </script>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://github.com/ChrisHRZ" class="iconfont icon-github" title="github"></a>
  <a href="https://chrishrz.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">ChrisHRZ</span>
  </span>
</div>


<script src="https://cdn.bootcss.com/mermaid/8.4.8/mermaid.min.js"></script>

<script src="https://cdn.bootcss.com/mathjax/2.7.7/MathJax.js"></script>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>








</body>
</html>
