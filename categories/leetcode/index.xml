<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on Focus-ChrisHRZ&#39;s blog</title>
    <link>https://chrishrz.github.io/categories/leetcode/</link>
    <description>Recent content in leetcode on Focus-ChrisHRZ&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 27 Apr 2020 15:32:13 +0800</lastBuildDate>
    
	<atom:link href="https://chrishrz.github.io/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Lc]面试题40_最小的k个数</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9840_%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Mon, 27 Apr 2020 15:32:13 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9840_%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</guid>
      <description>题目 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例 1： 输入</description>
    </item>
    
    <item>
      <title>[Lc]t84Largest_Rectangle_in_Histogram</title>
      <link>https://chrishrz.github.io/post/lct84largest_rectangle_in_histogram/</link>
      <pubDate>Sun, 26 Apr 2020 13:23:35 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct84largest_rectangle_in_histogram/</guid>
      <description>题目 Given n non-negative integers representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. Example: Input: [2,1,5,6,2,3] Output: 10 题解 1. 双数组法</description>
    </item>
    
    <item>
      <title>[Lc]t28Implement_strStr()</title>
      <link>https://chrishrz.github.io/post/lct28implement_strstr/</link>
      <pubDate>Fri, 24 Apr 2020 21:26:38 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct28implement_strstr/</guid>
      <description>题目 Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = &amp;ldquo;hello&amp;rdquo;, needle = &amp;ldquo;ll&amp;rdquo; Output: 2 Example 2: Input: haystack = &amp;ldquo;aaaaa&amp;rdquo;, needle = &amp;ldquo;bba&amp;rdquo; Output: -1 题解 1. 正则表达式 这个在leetcode上超时，未</description>
    </item>
    
    <item>
      <title>[Lc]t69Sqrt(x)</title>
      <link>https://chrishrz.github.io/post/lct69sqrtx/</link>
      <pubDate>Fri, 24 Apr 2020 20:27:31 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct69sqrtx/</guid>
      <description>题目 Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4 Output: 2 Example 2: Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842&amp;hellip;, and since the decimal part</description>
    </item>
    
    <item>
      <title>[Lc]t22Generate_Parentheses</title>
      <link>https://chrishrz.github.io/post/lct22generate_parentheses/</link>
      <pubDate>Tue, 21 Apr 2020 12:27:02 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct22generate_parentheses/</guid>
      <description>题目 Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ &amp;ldquo;((()))&amp;quot;, &amp;ldquo;(()())&amp;quot;, &amp;ldquo;(())()&amp;quot;, &amp;ldquo;()(())&amp;quot;, &amp;ldquo;()()()&amp;rdquo; ] 题解 1.递归法 class Solution { vector&amp;lt;string&amp;gt; res;//在私有变量定义res在存结果， public: vector&amp;lt;string&amp;gt; generateParenthesis(int n)</description>
    </item>
    
    <item>
      <title>[lc]#20Valid_Parentheses</title>
      <link>https://chrishrz.github.io/post/lct20valid_parentheses/</link>
      <pubDate>Tue, 21 Apr 2020 11:49:21 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct20valid_parentheses/</guid>
      <description>题目 Given a string containing just the characters &amp;lsquo;(&#39;, &amp;lsquo;)&#39;, &amp;lsquo;{&#39;, &amp;lsquo;}&#39;, &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&#39;, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: Input: &amp;ldquo;()&amp;rdquo; Output: true Example 2: Input: &amp;ldquo;()[]{}&amp;rdquo; Output: true</description>
    </item>
    
    <item>
      <title>[lc]#17Letter_Combinations_of_a_Phone_Number</title>
      <link>https://chrishrz.github.io/post/lct17letter_combinations_of_a_phone_number/</link>
      <pubDate>Mon, 20 Apr 2020 20:25:18 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct17letter_combinations_of_a_phone_number/</guid>
      <description>题目 Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. 题解 时间复杂度$O(3^{N}+4^{M})$，N是</description>
    </item>
    
    <item>
      <title>[Lc]t14Longest_Common_Prefix</title>
      <link>https://chrishrz.github.io/post/lct14longest_common_prefix/</link>
      <pubDate>Sat, 18 Apr 2020 21:01:06 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct14longest_common_prefix/</guid>
      <description>题目 Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string &amp;ldquo;&amp;quot;. Example 1: Input: [&amp;ldquo;flower&amp;rdquo;,&amp;ldquo;flow&amp;rdquo;,&amp;ldquo;flight&amp;rdquo;] Output: &amp;ldquo;fl&amp;rdquo; Example 2: Input: [&amp;ldquo;dog&amp;rdquo;,&amp;ldquo;racecar&amp;rdquo;,&amp;ldquo;car&amp;rdquo;] Output: &amp;quot;&amp;rdquo; Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. 题解 1. 遍历法 时间复杂度</description>
    </item>
    
    <item>
      <title>[Lc]t67Add_Binary</title>
      <link>https://chrishrz.github.io/post/lct67add_binary/</link>
      <pubDate>Mon, 13 Apr 2020 22:36:11 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct67add_binary/</guid>
      <description>题目 Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. Example 1: Input: a = &amp;ldquo;11&amp;rdquo;, b = &amp;ldquo;1&amp;rdquo; Output: &amp;ldquo;100&amp;rdquo; Example 2: Input: a = &amp;ldquo;1010&amp;rdquo;, b = &amp;ldquo;1011&amp;rdquo; Output: &amp;ldquo;10101&amp;rdquo; Constraints: Each string consists only of &amp;lsquo;0&amp;rsquo; or &amp;lsquo;1&amp;rsquo; characters. 1 &amp;lt;= a.length, b.length &amp;lt;= 10^4 Each string is either &amp;ldquo;0&amp;rdquo; or</description>
    </item>
    
    <item>
      <title>[lc]#31Next_Permutation</title>
      <link>https://chrishrz.github.io/post/lct31next_permutation/</link>
      <pubDate>Sun, 12 Apr 2020 00:34:19 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct31next_permutation/</guid>
      <description>题目 Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1</description>
    </item>
    
    <item>
      <title>[lc]#60Permutati_on_Sequence</title>
      <link>https://chrishrz.github.io/post/lct60permutati_on_sequence/</link>
      <pubDate>Sat, 11 Apr 2020 22:55:04 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct60permutati_on_sequence/</guid>
      <description>题目 The set [1,2,3,&amp;hellip;,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: &amp;ldquo;123&amp;rdquo; &amp;ldquo;132&amp;rdquo; &amp;ldquo;213&amp;rdquo; &amp;ldquo;231&amp;rdquo; &amp;ldquo;312&amp;rdquo; &amp;ldquo;321&amp;rdquo; Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive. Example 1: Input: n =</description>
    </item>
    
    <item>
      <title>[lc]#50Pow(x,n)</title>
      <link>https://chrishrz.github.io/post/lct50powxn/</link>
      <pubDate>Sat, 11 Apr 2020 22:04:52 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct50powxn/</guid>
      <description>题目 Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: Input: 2.00000, 10 Output: 1024.00000 Example 2: Input: 2.10000, 3 Output: 9.26100 Example 3: Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note: -100.0 &amp;lt; x &amp;lt; 100.0 n is a 32-bit signed integer, within the range [−231, 231 − 1] 题解 快</description>
    </item>
    
    <item>
      <title>[lc]#43Multiply_Strings</title>
      <link>https://chrishrz.github.io/post/lct43multiply_strings/</link>
      <pubDate>Sat, 11 Apr 2020 13:36:02 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct43multiply_strings/</guid>
      <description>题目 Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Example 1: Input: num1 = &amp;ldquo;2&amp;rdquo;, num2 = &amp;ldquo;3&amp;rdquo; Output: &amp;ldquo;6&amp;rdquo; Example 2: Input: num1 = &amp;ldquo;123&amp;rdquo;, num2 = &amp;ldquo;456&amp;rdquo; Output: &amp;ldquo;56088&amp;rdquo; Note: The length of both num1 and num2 is &amp;lt; 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do</description>
    </item>
    
    <item>
      <title>[lc]#29Divide_Two_Integers</title>
      <link>https://chrishrz.github.io/post/lct29divide_two_integers/</link>
      <pubDate>Fri, 10 Apr 2020 22:46:20 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct29divide_two_integers/</guid>
      <description>题目 Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero, which means losing its fractional part. For example, truncate(8.345) = 8 and truncate(-2.7335) = -2. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Explanation: 10/3 = truncate(3.33333..) = 3. Example 2: Input: dividend =</description>
    </item>
    
    <item>
      <title>[lc]#12Integer_to_Roman</title>
      <link>https://chrishrz.github.io/post/lct12integer_to_roman/</link>
      <pubDate>Fri, 10 Apr 2020 00:13:43 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct12integer_to_roman/</guid>
      <description>题目 Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is</description>
    </item>
    
    <item>
      <title>[lc]#222Count_Complete_Tree_Nodes</title>
      <link>https://chrishrz.github.io/post/lct222count_complete_tree_nodes/</link>
      <pubDate>Thu, 09 Apr 2020 11:03:58 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct222count_complete_tree_nodes/</guid>
      <description>题目 Given a complete binary tree, count the number of nodes. Note: Definition of a complete binary tree from Wikipedia: In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Example: Input: 1 / \ 2 3 /</description>
    </item>
    
    <item>
      <title>[lc]#226Invert_Binary_Tree</title>
      <link>https://chrishrz.github.io/post/lct226invert_binary_tree/</link>
      <pubDate>Wed, 08 Apr 2020 22:48:38 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct226invert_binary_tree/</guid>
      <description>题目 Invert a binary tree. Example: Input: 4 / \ 2 7 / \ / \ 1 3 6 9 Output: 4 / \ 7 2 / \ / \ 9 6 3 1 Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on</description>
    </item>
    
    <item>
      <title>[lc]#199Binary_Tree_Right_Side_View</title>
      <link>https://chrishrz.github.io/post/lct199binary_tree_right_side_view/</link>
      <pubDate>Wed, 08 Apr 2020 22:14:18 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct199binary_tree_right_side_view/</guid>
      <description>题目 Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 &amp;lt;--- / \ 2 3 &amp;lt;--- \ \ 5 4 &amp;lt;--- 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val;</description>
    </item>
    
    <item>
      <title>[lc]#173Binary_Search_Tree_Iterators</title>
      <link>https://chrishrz.github.io/post/lct173binary_search_tree_iterators/</link>
      <pubDate>Wed, 08 Apr 2020 18:20:18 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct173binary_search_tree_iterators/</guid>
      <description>题目 Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Example: BSTIterator iterator = new BSTIterator(root); iterator.next(); // return 3 iterator.next(); // return 7 iterator.hasNext(); // return true iterator.next(); // return 9 iterator.hasNext(); // return true iterator.next(); // return 15 iterator.hasNext(); // return true iterator.next(); //</description>
    </item>
    
    <item>
      <title>[lc]#129Sum_Root_to_Leaf_Numbers</title>
      <link>https://chrishrz.github.io/post/lct129sum_root_to_leaf_numbers/</link>
      <pubDate>Wed, 08 Apr 2020 13:24:46 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct129sum_root_to_leaf_numbers/</guid>
      <description>题目 Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&amp;gt;2-&amp;gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: Input: [1,2,3] 1 / \ 2 3 Output: 25 Explanation: The root-to-leaf path 1-&amp;gt;2 represents the number 12. The root-to-leaf path 1-&amp;gt;3</description>
    </item>
    
    <item>
      <title>[lc]#117Populating_Next_Right_Pointers_in_Each_Node2</title>
      <link>https://chrishrz.github.io/post/lct117populating_next_right_pointers_in_each_node2/</link>
      <pubDate>Wed, 08 Apr 2020 11:41:56 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct117populating_next_right_pointers_in_each_node2/</guid>
      <description>题目 Given a binary tree struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Follow up: You may only use constant extra space. Recursive approach is fine, you may assume implicit stack</description>
    </item>
    
    <item>
      <title>[lc]#116Populating_Next_Right_Pointers_in_Each_Node</title>
      <link>https://chrishrz.github.io/post/lct116populating_next_right_pointers_in_each_node/</link>
      <pubDate>Tue, 07 Apr 2020 22:15:10 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct116populating_next_right_pointers_in_each_node/</guid>
      <description>题目 You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all</description>
    </item>
    
    <item>
      <title>[lc]#114Flatten_Binary_Tree_to_LinkedList</title>
      <link>https://chrishrz.github.io/post/lct114flatten_binary_tree_to_linkedlist/</link>
      <pubDate>Tue, 07 Apr 2020 20:12:38 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct114flatten_binary_tree_to_linkedlist/</guid>
      <description>面试中题目大多以英文呈现，因此后面的[lc]文章题目改为英文,已经发表的博客后面有时间再修改 题目 Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 1 / \ 2 5</description>
    </item>
    
    <item>
      <title>[lc]#113路径总和2</title>
      <link>https://chrishrz.github.io/post/lct113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C2/</link>
      <pubDate>Fri, 27 Mar 2020 22:34:03 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C2/</guid>
      <description>题目 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 给定如下二</description>
    </item>
    
    <item>
      <title>[lc]t112路径总和</title>
      <link>https://chrishrz.github.io/post/lct112%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</link>
      <pubDate>Fri, 20 Mar 2020 20:06:36 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct112%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</guid>
      <description>题目 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的</description>
    </item>
    
    <item>
      <title>[lc]t111二叉树的最小深度</title>
      <link>https://chrishrz.github.io/post/lct111%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Wed, 18 Mar 2020 17:10:27 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct111%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</guid>
      <description>题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二</description>
    </item>
    
    <item>
      <title>[lc]#110平衡二叉树</title>
      <link>https://chrishrz.github.io/post/lct110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 17 Mar 2020 16:32:45 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1</description>
    </item>
    
    <item>
      <title>[lc]#174二叉树的层次遍历2</title>
      <link>https://chrishrz.github.io/post/lct174%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%862/</link>
      <pubDate>Tue, 17 Mar 2020 14:01:58 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct174%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%862/</guid>
      <description>题目 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如： 给定二叉树 [3,9,20,null,null,15,7] 3 / \ 9 20 /</description>
    </item>
    
    <item>
      <title>[lc]#104二叉树的最大深度</title>
      <link>https://chrishrz.github.io/post/lct104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Tue, 17 Mar 2020 13:12:19 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid>
      <description>题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二</description>
    </item>
    
    <item>
      <title>[lc]#103二叉树的锯齿层次遍历</title>
      <link>https://chrishrz.github.io/post/lct103%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</link>
      <pubDate>Tue, 17 Mar 2020 11:48:54 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct103%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</guid>
      <description>题目 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如： 给定二叉树</description>
    </item>
    
    <item>
      <title>[lc]#102二叉树的层次遍历</title>
      <link>https://chrishrz.github.io/post/lct102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sun, 15 Mar 2020 15:03:26 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</guid>
      <description>题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 队列迭代法 class Solution {//两种方法。1、队列迭代法。 public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; if(!root) return res; //定</description>
    </item>
    
    <item>
      <title>[lc]#101对称二叉树</title>
      <link>https://chrishrz.github.io/post/lct101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sat, 14 Mar 2020 19:54:18 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 class Solution {//三种方法。1、递归法。有点像#100 public: bool isSymmetric(TreeNode* root) { if(!root) return tru</description>
    </item>
    
    <item>
      <title>[lc]#100相同的树</title>
      <link>https://chrishrz.github.io/post/lct100%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</link>
      <pubDate>Sat, 14 Mar 2020 19:27:58 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct100%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</guid>
      <description>题解 这道题就是遍历。这里写一个先序遍历，其他遍历方式见相应例题。 二叉树的遍历包括DFS(深度优先搜索)的先序遍历、中序遍历、后序遍历。 还有B</description>
    </item>
    
    <item>
      <title>[lc]#98验证二叉搜索树</title>
      <link>https://chrishrz.github.io/post/lct98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sat, 14 Mar 2020 13:53:22 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题解 TreeNode的定义： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ 1. 直接递归法 class Solution {//三种方法。1、直接递归。利</description>
    </item>
    
    <item>
      <title>[lc]#95不同的二叉搜索树2</title>
      <link>https://chrishrz.github.io/post/lct95%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</link>
      <pubDate>Sat, 14 Mar 2020 00:59:26 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct95%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</guid>
      <description>题目 给定一个整数 n，生成所有由 1 &amp;hellip; n 为节点所组成的二叉搜索树。 示例: 输入: 3 输出: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] 解释: 以上的输出对应以下 5 种不同结构的二叉搜</description>
    </item>
    
    <item>
      <title>[lc]#96不同的二叉搜索树</title>
      <link>https://chrishrz.github.io/post/lct96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Fri, 13 Mar 2020 12:26:13 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>给定一个整数 n，求以 1 &amp;hellip; n 为节点组成的二叉搜索树有多少种？ 示例： 输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \</description>
    </item>
    
    <item>
      <title>[lc]#94#144#145二叉树的三种遍历</title>
      <link>https://chrishrz.github.io/post/lct94t144t145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 09 Mar 2020 11:28:56 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct94t144t145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/</guid>
      <description>二叉树的遍历 简单地理解，满足以下两个条件的树就是二叉树： 本身是有序树； 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2； 下图即一颗二叉</description>
    </item>
    
  </channel>
</rss>