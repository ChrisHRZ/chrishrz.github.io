<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on Focus-ChrisHRZ&#39;s blog</title>
    <link>uildDrafts/categories/leetcode/</link>
    <description>Recent content in leetcode on Focus-ChrisHRZ&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
<<<<<<< HEAD
<<<<<<< HEAD
    <lastBuildDate>Tue, 17 Mar 2020 16:32:45 +0800</lastBuildDate>
=======
    <lastBuildDate>Sat, 14 Mar 2020 13:53:22 +0800</lastBuildDate>
>>>>>>> parent of 02996ee... 添加了一些post,增加了mathjax,增加了google,baidu收录
=======
    <lastBuildDate>Sat, 14 Mar 2020 13:53:22 +0800</lastBuildDate>
>>>>>>> parent of 02996ee... 添加了一些post,增加了mathjax,增加了google,baidu收录
    
	<atom:link href="uildDrafts/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
<<<<<<< HEAD
<<<<<<< HEAD
      <title>[Lc]t110平衡二叉树</title>
      <link>uildDrafts/post/lct110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 17 Mar 2020 16:32:45 +0800</pubDate>
      
      <guid>uildDrafts/post/lct110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1</description>
    </item>
    
    <item>
      <title>[lc]#174二叉树的层次遍历2</title>
      <link>uildDrafts/post/lct174%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%862/</link>
      <pubDate>Tue, 17 Mar 2020 14:01:58 +0800</pubDate>
      
      <guid>uildDrafts/post/lct174%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%862/</guid>
      <description>题目 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如： 给定二叉树 [3,9,20,null,null,15,7] 3 / \ 9 20 /</description>
    </item>
    
    <item>
      <title>[lc]#104二叉树的最大深度</title>
      <link>uildDrafts/post/lct104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Tue, 17 Mar 2020 13:12:19 +0800</pubDate>
      
      <guid>uildDrafts/post/lct104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid>
      <description>题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二</description>
    </item>
    
    <item>
      <title>[lc]#103二叉树的锯齿层次遍历</title>
      <link>uildDrafts/post/lct103%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</link>
      <pubDate>Tue, 17 Mar 2020 11:48:54 +0800</pubDate>
      
      <guid>uildDrafts/post/lct103%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</guid>
      <description>题目 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如： 给定二叉树</description>
    </item>
    
    <item>
      <title>[lc]#102二叉树的层次遍历</title>
      <link>uildDrafts/post/lct102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sun, 15 Mar 2020 15:03:26 +0800</pubDate>
      
      <guid>uildDrafts/post/lct102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</guid>
      <description>题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 队列迭代法 class Solution {//两种方法。1、队列迭代法。 public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; if(!root) return res; //定</description>
    </item>
    
    <item>
      <title>[lc]#101对称二叉树</title>
      <link>uildDrafts/post/lct101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sat, 14 Mar 2020 19:54:18 +0800</pubDate>
      
      <guid>uildDrafts/post/lct101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 class Solution {//三种方法。1、递归法。有点像#100 public: bool isSymmetric(TreeNode* root) { if(!root) return tru</description>
    </item>
    
    <item>
      <title>[lc]#100相同的树</title>
      <link>uildDrafts/post/lct100%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</link>
      <pubDate>Sat, 14 Mar 2020 19:27:58 +0800</pubDate>
      
      <guid>uildDrafts/post/lct100%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</guid>
      <description>题解 这道题就是遍历。这里写一个先序遍历，其他遍历方式见相应例题。 二叉树的遍历包括DFS(深度优先搜索)的先序遍历、中序遍历、后序遍历。 还有B</description>
    </item>
    
    <item>
=======
>>>>>>> parent of 02996ee... 添加了一些post,增加了mathjax,增加了google,baidu收录
=======
>>>>>>> parent of 02996ee... 添加了一些post,增加了mathjax,增加了google,baidu收录
      <title>[lc]#98验证二叉搜索树</title>
      <link>uildDrafts/post/lct98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sat, 14 Mar 2020 13:53:22 +0800</pubDate>
      
      <guid>uildDrafts/post/lct98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题解 TreeNode的定义： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ 1. 直接递归法 class Solution {//三种方法。1、直接递归。利</description>
    </item>
    
    <item>
      <title>[lc]#95不同的二叉搜索树2</title>
      <link>uildDrafts/post/lct95%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</link>
      <pubDate>Sat, 14 Mar 2020 00:59:26 +0800</pubDate>
      
<<<<<<< HEAD
<<<<<<< HEAD
      <guid>uildDrafts/post/lct95%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</guid>
      <description>题目 给定一个整数 n，生成所有由 1 &amp;hellip; n 为节点所组成的二叉搜索树。 示例: 输入: 3 输出: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] 解释: 以上的输出对应以下 5 种不同结构的二叉搜</description>
=======
      <guid>http://chrishrz.github.io/post/lct95%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</guid>
      <description>题解 1. 递归法 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution {//#96的升级版。两种方法。1、递归 public: vector&amp;lt;TreeNode*&amp;gt; generateTrees(int n) { vector&amp;lt;TreeNode*&amp;gt; ans; if(n==0) return a</description>
>>>>>>> parent of 02996ee... 添加了一些post,增加了mathjax,增加了google,baidu收录
=======
      <guid>http://chrishrz.github.io/post/lct95%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</guid>
      <description>题解 1. 递归法 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution {//#96的升级版。两种方法。1、递归 public: vector&amp;lt;TreeNode*&amp;gt; generateTrees(int n) { vector&amp;lt;TreeNode*&amp;gt; ans; if(n==0) return a</description>
>>>>>>> parent of 02996ee... 添加了一些post,增加了mathjax,增加了google,baidu收录
    </item>
    
    <item>
      <title>[lc]#96不同的二叉搜索树</title>
      <link>uildDrafts/post/lct96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Fri, 13 Mar 2020 12:26:13 +0800</pubDate>
      
      <guid>uildDrafts/post/lct96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>给定一个整数 n，求以 1 &amp;hellip; n 为节点组成的二叉搜索树有多少种？ 示例： 输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \</description>
    </item>
    
    <item>
      <title>[lc]#94#144#145二叉树的三种遍历</title>
      <link>uildDrafts/post/lct94t144t145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 09 Mar 2020 11:28:56 +0800</pubDate>
      
      <guid>uildDrafts/post/lct94t144t145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/</guid>
      <description>二叉树的遍历 简单地理解，满足以下两个条件的树就是二叉树： 本身是有序树； 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2； 下图即一颗二叉</description>
    </item>
    
  </channel>
</rss>