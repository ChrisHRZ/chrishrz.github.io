<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>链表 on Focus-ChrisHRZ&#39;s blog</title>
    <link>https://chrishrz.github.io/tags/%E9%93%BE%E8%A1%A8/</link>
    <description>Recent content in 链表 on Focus-ChrisHRZ&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 21 Jun 2020 21:18:04 +0800</lastBuildDate>
    
	<atom:link href="https://chrishrz.github.io/tags/%E9%93%BE%E8%A1%A8/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Lc]面试题52两个链表的第一个公共节点</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9852%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sun, 21 Jun 2020 21:18:04 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9852%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</guid>
      <description>题目 链表定义： //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 题解 1. 双指针法交替遍历 时间复杂度$O(n)$ 空间复杂度$O(1)$ 从两个链表的表头开始遍历</description>
    </item>
    
    <item>
      <title>[Lc]160相交链表</title>
      <link>https://chrishrz.github.io/post/lc160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 21 Jun 2020 17:50:26 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 链表定义： //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 题解 1. 双指针法交替遍历 时间复杂度$O(n)$ 空间复杂度$O(1)$ 从两个链表的表头开始遍历</description>
    </item>
    
    <item>
      <title>[Lc]面试题36二叉搜索树与双向链表</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9836%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 20 May 2020 12:05:20 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9836%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 题解 节点定义如下： // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node() {} Node(int _val) { val = _val; left = NULL; right = NULL; } Node(int _val, Node* _left, Node* _right) { val = _val; left = _left; right = _right; } }; 这道题要利用二叉搜索树</description>
    </item>
    
    <item>
      <title>[Lc]426将二叉搜索树转化为排序的双向链表</title>
      <link>https://chrishrz.github.io/post/lc426%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 20 May 2020 11:58:34 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc426%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 题解 节点定义如下： // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node() {} Node(int _val) { val = _val; left = NULL; right = NULL; } Node(int _val, Node* _left, Node* _right) { val = _val; left = _left; right = _right; } }; 这道题要利用二叉搜索树</description>
    </item>
    
    <item>
      <title>[Lc]138复制带随机指针的链表</title>
      <link>https://chrishrz.github.io/post/lc138%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 19 May 2020 20:06:03 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc138%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 题解 链表定义： // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; 1. 复制链表节点法 在每个节点后复制新的节点，三次遍历 先复制新的节点</description>
    </item>
    
    <item>
      <title>[Lc]面试题35复杂链表的复制</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9835%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Tue, 19 May 2020 20:02:50 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9835%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</guid>
      <description>题目 题解 链表定义： // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; 详细注释看138题 1. 复制链表节点法 在每个节点后复制新的节点，三次</description>
    </item>
    
    <item>
      <title>[Lc]面试题27二叉树的镜像</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9827%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link>
      <pubDate>Sat, 16 May 2020 11:31:08 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9827%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 这个方法就是递归的翻转左右子树，若遇到空子树直接返回，然后当前</description>
    </item>
    
    <item>
      <title>[Lc]面试题26树的子结构</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9826%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 15 May 2020 21:22:56 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9826%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 双递归法 两个递归函数，一个用来看当前节点是否匹配，一个用来遍历a的所</description>
    </item>
    
    <item>
      <title>[Lc]面试题25合并两个排序的链表</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9825%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 15 May 2020 17:43:28 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9825%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 链表定义： //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 题解 这道题的思想是链表归并排序中的一个重要环节，即对有序的两个链表进行归并。比较表头，小的</description>
    </item>
    
    <item>
      <title>[Lc]21合并两个有序链表</title>
      <link>https://chrishrz.github.io/post/lc21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 15 May 2020 17:36:13 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 链表定义： //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 题解 这道题的思想是链表归并排序中的一个重要环节，即对有序的两个链表进行归并。比较表头，小的</description>
    </item>
    
    <item>
      <title>[Lc]206反转链表</title>
      <link>https://chrishrz.github.io/post/lc206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 15 May 2020 17:08:28 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 链表定义： //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 题解 1. 迭代法（双指针） 实际上是三个指针，一个指向当前节点之前pre，一个指向当前节点cur</description>
    </item>
    
    <item>
      <title>[Lc]面试题24反转链表</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9824%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 15 May 2020 16:31:44 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9824%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 链表定义： //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 题解 1. 迭代法（双指针） 实际上是三个指针，一个指向当前节点之前pre，一个指向当前节点cur</description>
    </item>
    
    <item>
      <title>[Lc]面试题22链表中倒数第k个节点</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9822%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 14 May 2020 21:25:53 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9822%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>题目 题解 快慢指针 时间复杂度$O(n)$ 空间复杂度$O(1)$ class Solution { public: ListNode* getKthFromEnd(ListNode* head, int k) { if(k==0 || !head) return nullptr; ListNode *fast = head, *slow = head; int n = 0; while(fast){ if(n &amp;gt;= k) slow = slow-&amp;gt;next; fast = fast-&amp;gt;next; n++; } if(n&amp;lt;k) return</description>
    </item>
    
    <item>
      <title>[Lc]面试题18删除链表的节点</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9818%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Wed, 13 May 2020 21:39:00 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9818%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>题目 链表定义： //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 题解 这题简单，两个指针，一个指向cur，一个是cur之前pre。当cur的值为val时，p</description>
    </item>
    
    <item>
      <title>[Lc]面试题06从尾到头打印链表</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9806%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 10 May 2020 17:46:46 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9806%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 题解 //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 1. 栈 从头到尾遍历链表，先取数入栈，再从栈中弹出放入数组 时间复杂度$O(n)$，遍历一次数组一次栈</description>
    </item>
    
    <item>
      <title>[Lc]141环形链表</title>
      <link>https://chrishrz.github.io/post/lc141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 08 May 2020 21:12:47 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 链表定义： //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 题解 142的简化版，202的方法来源 1. 快慢指针法 时间复杂度$O(n)$ 空间复杂度$O(1)</description>
    </item>
    
    <item>
      <title>[Lc]142环形链表II</title>
      <link>https://chrishrz.github.io/post/lc142%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</link>
      <pubDate>Fri, 08 May 2020 20:48:24 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc142%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</guid>
      <description>题目 链表定义： //Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 题解 141的进阶 1. 快慢指针法 设环长度为c，环前端长度为a，相遇点到环前端长度为y 快指针在一</description>
    </item>
    
  </channel>
</rss>