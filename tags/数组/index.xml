<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数组 on Focus-ChrisHRZ&#39;s blog</title>
    <link>https://chrishrz.github.io/tags/%E6%95%B0%E7%BB%84/</link>
    <description>Recent content in 数组 on Focus-ChrisHRZ&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 30 Jun 2020 11:22:21 +0800</lastBuildDate>
    
	<atom:link href="https://chrishrz.github.io/tags/%E6%95%B0%E7%BB%84/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Lc]面试题63股票的最大利润</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9863%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</link>
      <pubDate>Tue, 30 Jun 2020 11:22:21 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9863%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</guid>
      <description>题目 题解 动态规划的思想。即一次遍历，寻找两个数，一个是当前的全局最小值，一个是在当前的全局最小值后可以得到的最大差值 时间复杂度$O(n)$ 空</description>
    </item>
    
    <item>
      <title>[Lc]121买卖股票的最佳时机</title>
      <link>https://chrishrz.github.io/post/lc121%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</link>
      <pubDate>Tue, 30 Jun 2020 11:13:51 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc121%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</guid>
      <description>题目 题解 动态规划的思想。即一次遍历，寻找两个数，一个是当前的全局最小值，一个是在当前的全局最小值后可以得到的最大差值 时间复杂度$O(n)$ 空</description>
    </item>
    
    <item>
      <title>[Lc]面试题57_II和为s的连续正数序列</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9857_ii%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</link>
      <pubDate>Fri, 26 Jun 2020 22:21:12 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9857_ii%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</guid>
      <description>题目 题解 1. 暴力法 挨个计算所有数组的和，时间复杂度太高 时间复杂度: $O(n^{2})$ 空间复杂度: $O(1)$ 2. 滑动窗口法 看注释吧，不太难，证明可以看题解 时间复杂度: $O(n)$ 空</description>
    </item>
    
    <item>
      <title>[Lc]面试题57_I和为s的两个数字</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9857_i%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</link>
      <pubDate>Thu, 25 Jun 2020 20:09:52 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9857_i%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</guid>
      <description>题目 题解 可以用哈希表，但是需要用额外的存储空间，这道题有递增的性质，直接双指针，很简单，看代码就可以。 时间复杂度: $O(n)$ 空间复杂度: $O(1)$ class Solution { public: vector&amp;lt;int&amp;gt;</description>
    </item>
    
    <item>
      <title>[Lc]1两数之和</title>
      <link>https://chrishrz.github.io/post/lc1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Thu, 25 Jun 2020 19:30:14 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>题目 题解 1. 暴力法 就是挨个两两相加，找到相加为target的两个数。会超时，比较好写，这里不写了 时间复杂度$O(n^{2})$ 空间复杂度$O(</description>
    </item>
    
    <item>
      <title>[Lc]面试题56_II数组中数字出现的次数II</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9856_ii%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0ii/</link>
      <pubDate>Wed, 24 Jun 2020 17:09:28 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9856_ii%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0ii/</guid>
      <description>题目 题解 1. 有限状态机 详细题解看这里。这里放几张来自该题解的图。详细题解还是看 Krahets 大神的题解吧。 时间复杂度: $O(n)$ 空间复杂度: $O(1)$ 重点掌握one和tw</description>
    </item>
    
    <item>
      <title>[Lc]面试题56_I数组中数字出现的次数</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9856_i%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Wed, 24 Jun 2020 16:29:29 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9856_i%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</guid>
      <description>题目 题解 我们先来看下异或的性质（数学里异或的符号是 $\oplus$）： 交换律：$p \oplus q = q \oplus p$ 结合律：$p \oplus (q \oplus r) = (p \oplus q) \oplus r$ 恒等率：$p \oplus</description>
    </item>
    
    <item>
      <title>[Lc]面试题53_II</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9853_ii.0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Tue, 23 Jun 2020 14:10:37 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9853_ii.0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目 题解 1. 挨个查找法 时间复杂度$O(N)$ 空间复杂度$O(1)$ 就是挨个查找数组，找到与下标不一致的数即可，但不是最右的方法 2. 二分查找法 时间</description>
    </item>
    
    <item>
      <title>[Lc]面试题53_I在排序数组中查找数字I</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9853_i%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97i/</link>
      <pubDate>Mon, 22 Jun 2020 20:02:46 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9853_i%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97i/</guid>
      <description>题目 题解 1. 挨个查找法 时间复杂度$O(N)$ 空间复杂度$O(1)$ 就是挨个查找数组，找到的第一个就是开始位置，找到的最后一个就是结束位置。 这个</description>
    </item>
    
    <item>
      <title>[Lc]34在排序数组中查找元素的第一个和最后一个位置</title>
      <link>https://chrishrz.github.io/post/lc34%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Mon, 22 Jun 2020 19:42:13 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc34%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</guid>
      <description>题目 题解 1. 挨个查找法 时间复杂度$O(N)$ 空间复杂度$O(1)$ 就是挨个查找数组，找到的第一个就是开始位置，找到的最后一个就是结束位置。 这个</description>
    </item>
    
    <item>
      <title>[Lc]面试题51数组中的逆序对</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9851%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</link>
      <pubDate>Sun, 14 Jun 2020 17:31:50 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9851%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</guid>
      <description>题目 题解 三个方法 1. 暴力法 必超时，挨个比较每两个数 时间复杂度$O(n^{2})$ 空间复杂度$O(1)$ 2. 归并排序法 就是用归并排序的思想，在归并</description>
    </item>
    
    <item>
      <title>[Lc]295数据流的中位数</title>
      <link>https://chrishrz.github.io/post/lc295%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Wed, 03 Jun 2020 18:17:03 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc295%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>题目 //Your MedianFinder object will be instantiated and called as such: MedianFinder* obj = new MedianFinder(); obj-&amp;gt;addNum(num); double param_2 = obj-&amp;gt;findMedian(); 题解 有三种方法 1. 插入排序法 在插入每一个数时使用插入排序的思路，这样在取数的时候只需要取中间的数（</description>
    </item>
    
    <item>
      <title>[Lc]面试题41数据流中的中位数</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9841%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Wed, 03 Jun 2020 18:16:44 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9841%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>题目 //Your MedianFinder object will be instantiated and called as such: MedianFinder* obj = new MedianFinder(); obj-&amp;gt;addNum(num); double param_2 = obj-&amp;gt;findMedian(); 题解 有三种方法 1. 插入排序法 在插入每一个数时使用插入排序的思路，这样在取数的时候只需要取中间的数（</description>
    </item>
    
    <item>
      <title>[Lc]面试题39数组中出现次数超过一半的数字</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9839%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 20 May 2020 21:51:06 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9839%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目 题解 详细注释见169题，这里再练习一下 1. 排序取中法 时间复杂度$O(nlog{n})$，主要是排序耗费的 空间复杂度$O(1)$ class Solution {//三</description>
    </item>
    
    <item>
      <title>[Lc]169多数元素</title>
      <link>https://chrishrz.github.io/post/lc169%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</link>
      <pubDate>Wed, 20 May 2020 21:36:39 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc169%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</guid>
      <description>题目 题解 1. 排序取中法 时间复杂度$O(nlog{n})$，主要是排序耗费的 空间复杂度$O(1)$ class Solution {//三种方法，这是1.排序后取中间数 //</description>
    </item>
    
    <item>
      <title>[Lc]54螺旋矩阵</title>
      <link>https://chrishrz.github.io/post/lc54%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Sun, 17 May 2020 17:10:02 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc54%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</guid>
      <description>题目 题解 就是分四种情况，从左到右，上到下，右到左，下到上循环遍历，和59题类似 时间复杂度$O(nm)$ 空间复杂度$O(nm)$ class Solution { public: vector&amp;lt;int&amp;gt; spiralOrder(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix)</description>
    </item>
    
    <item>
      <title>[Lc]59螺旋矩阵II</title>
      <link>https://chrishrz.github.io/post/lc59%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5ii/</link>
      <pubDate>Sun, 17 May 2020 17:07:32 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc59%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5ii/</guid>
      <description>题目 题解 就是分四种情况，从左到右，上到下，右到左，下到上循环遍历，和54题类似 时间复杂度$O(nm)$ 空间复杂度$O(nm)$ class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generateMatrix(int n)</description>
    </item>
    
    <item>
      <title>[Lc]面试题29顺时针打印矩阵</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9829%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Sun, 17 May 2020 17:07:04 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9829%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</guid>
      <description>题目 题解 直接迭代，四个方向将结果输入res，注意边界条件的判断 时间复杂度$O(n)$ 空间复杂度$O(n)$ class Solution { public: vector&amp;lt;int&amp;gt; spiralOrder(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { vector&amp;lt;int&amp;gt; res; if(matrix.empty()) return res; int u=0, d=matrix.size()-1, l=0,</description>
    </item>
    
    <item>
      <title>[Lc]面试题21调整数组顺序使奇数位于偶数前面</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9821%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</link>
      <pubDate>Thu, 14 May 2020 21:14:29 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9821%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</guid>
      <description>题目 题解 双指针，左找到偶数，右找到奇数，然后交换，继续循环 时间复杂度$O(n)$ 空间复杂度$O(1)$，原地交换 class Solution { public: vector&amp;lt;int&amp;gt; exchange(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int p1=0, p2 = nums.size()-1; while(p1&amp;lt;p2){</description>
    </item>
    
    <item>
      <title>[Lc]面试题13机器人的运动范围</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9813%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</link>
      <pubDate>Mon, 11 May 2020 21:31:13 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9813%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</guid>
      <description>题目 题解 1. DFS 利用递归实现DFS搜索，注意要使用一个额外的矩阵保存已经访问过的位置，防止重复访问。当越界或者不满足数位条件或者已经访问过的时候</description>
    </item>
    
    <item>
      <title>[Lc]面试题12矩阵中的路径</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9812%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Mon, 11 May 2020 18:32:06 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9812%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description>题目 注意：本题与主站 79 题相同：(https://leetcode-cn.com/problems/word-search/) 题解 这道题用递归</description>
    </item>
    
    <item>
      <title>[Lc]79单词搜索</title>
      <link>https://chrishrz.github.io/post/lc79%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Mon, 11 May 2020 18:18:49 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc79%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</guid>
      <description>题目 题解 这道题用递归，DFS，找到和首字母相同的就继续找下去，找到不同的就回溯再找首字母 时间复杂度：${\mathcal{O}}((M\ti</description>
    </item>
    
    <item>
      <title>[Lc]面试题11旋转数组的最小数字</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9811%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</link>
      <pubDate>Mon, 11 May 2020 17:38:36 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9811%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</guid>
      <description>题目 注意：本题与主站 154 题相同：(https://leetcode-cn.com/problems/find-minimum-in-rotat</description>
    </item>
    
    <item>
      <title>[Lc]154寻找旋转排序数组中的最小值II</title>
      <link>https://chrishrz.github.io/post/lc154%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCii/</link>
      <pubDate>Mon, 11 May 2020 13:29:04 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc154%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCii/</guid>
      <description>题目 题解 这道题与153题类似，是其进阶，主要是出现了重复元素，因此要加上情况三的判断 如果中间的数小于最右边的数，则右半段是有序的,最小值在左</description>
    </item>
    
    <item>
      <title>[Lc]33搜索旋转排序数组</title>
      <link>https://chrishrz.github.io/post/lc33%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 11 May 2020 13:08:34 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc33%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>题目 题解 题目要求的复杂度一看就得联想到二分查找，这道题需要先分析一下如何二分查找，看下面的数组进行分析 如果中间的数小于最右边的数，则右半段是</description>
    </item>
    
    <item>
      <title>[Lc]153寻找旋转排序数组中的最小值</title>
      <link>https://chrishrz.github.io/post/lc153%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</link>
      <pubDate>Mon, 11 May 2020 13:05:17 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc153%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</guid>
      <description>题目 题解 这题与33题类似，33是查找，这一题是找最小值，也要利用旋转数组的性质 如果中间的数小于等于最右边的数，则右半段是有序的,最小值在左半</description>
    </item>
    
    <item>
      <title>[Lc]74搜索二维矩阵</title>
      <link>https://chrishrz.github.io/post/lc74%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Sat, 09 May 2020 21:27:34 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc74%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</guid>
      <description>题目 题解 稍微变形的二分查找，其实写法是一样的，主要就是在取mid的时候需要转化一下，开始取二分查找最初的left和right也要注意，还有二</description>
    </item>
    
    <item>
      <title>[Lc]240搜索二维矩阵II</title>
      <link>https://chrishrz.github.io/post/lc240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/</link>
      <pubDate>Sat, 09 May 2020 21:12:12 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5ii/</guid>
      <description>题目 题解 可以一行一行的二分查找，但是比较慢，也没有利用这道题矩阵的性质 确定起点很重要，由于这道题矩阵的特殊形式，我们可以将起点定在右上（或者</description>
    </item>
    
    <item>
      <title>[Lc]面试题04二维数组中的查找</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9804%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sat, 09 May 2020 21:06:19 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9804%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</guid>
      <description>题目 240题 题解 可以一行一行的二分查找，但是比较慢，也没有利用这道题矩阵的性质 确定起点很重要，由于这道题矩阵的特殊形式，我们可以将起点定在右</description>
    </item>
    
    <item>
      <title>[Lc]面试题03数组中重复的数字</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9803%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Sat, 09 May 2020 17:53:52 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9803%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>题目 题解 1. 排序法（改变输入数组） 数组排序后找重复项 时间复杂度$O(nlog{n})$，主要是排序花费的 空间复杂度$O(1)$ class Solution {//三种方</description>
    </item>
    
    <item>
      <title>[Lc]面试题40最小的k个数</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9840%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Mon, 27 Apr 2020 15:32:13 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9840%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</guid>
      <description>题目 题解 1. 堆法 时间复杂度：$O(n\log k)$，其中 nn 是数组 arr 的长度。由于大根堆实时维护前 k 小值，所以插入删除都是 $O(\log k)$ 的时间复杂度，最坏情</description>
    </item>
    
    <item>
      <title>[Lc]84柱状图中最大的矩形</title>
      <link>https://chrishrz.github.io/post/lc84%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</link>
      <pubDate>Sun, 26 Apr 2020 13:23:35 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc84%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</guid>
      <description>题目 题解 1. 双数组法 时间复杂度$O(N)$ 空间复杂度$O(N)$ class Solution { public: int largestRectangleArea(vector&amp;lt;int&amp;gt;&amp;amp; heights) {//多种方法，可以暴力搜索，但会超时，这里用时间复杂度较低的方</description>
    </item>
    
  </channel>
</rss>