<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>lc#96 on Focus-ChrisHRZ&#39;s blog</title>
    <link>http://chrishrz.github.io/tags/lc#96/</link>
    <description>Recent content in lc#96 on Focus-ChrisHRZ&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 14 Mar 2020 00:59:26 +0800</lastBuildDate>
    
	<atom:link href="http://chrishrz.github.io/tags/lc#96/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[lc]#95不同的二叉搜索树2</title>
      <link>http://chrishrz.github.io/post/lct95%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</link>
      <pubDate>Sat, 14 Mar 2020 00:59:26 +0800</pubDate>
      
      <guid>http://chrishrz.github.io/post/lct95%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</guid>
      <description>题解 1. 递归法 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution {//#96的升级版。两种方法。1、递归 public: vector&amp;lt;TreeNode*&amp;gt; generateTrees(int n) { vector&amp;lt;TreeNode*&amp;gt; ans; if(n==0) return a</description>
    </item>
    
    <item>
      <title>[lc]#96不同的二叉搜索树</title>
      <link>http://chrishrz.github.io/post/lct96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Fri, 13 Mar 2020 12:26:13 +0800</pubDate>
      
      <guid>http://chrishrz.github.io/post/lct96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>给定一个整数 n，求以 1 &amp;hellip; n 为节点组成的二叉搜索树有多少种？ 示例： 输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \</description>
    </item>
    
  </channel>
</rss>