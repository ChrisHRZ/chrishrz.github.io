<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>String on Focus-ChrisHRZ&#39;s blog</title>
    <link>https://chrishrz.github.io/tags/string/</link>
    <description>Recent content in String on Focus-ChrisHRZ&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 21 Apr 2020 12:27:02 +0800</lastBuildDate>
    
	<atom:link href="https://chrishrz.github.io/tags/string/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Lc]t22Generate_Parentheses</title>
      <link>https://chrishrz.github.io/post/lct22generate_parentheses/</link>
      <pubDate>Tue, 21 Apr 2020 12:27:02 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct22generate_parentheses/</guid>
      <description>题目 Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ &amp;ldquo;((()))&amp;quot;, &amp;ldquo;(()())&amp;quot;, &amp;ldquo;(())()&amp;quot;, &amp;ldquo;()(())&amp;quot;, &amp;ldquo;()()()&amp;rdquo; ] 题解 1.递归法 class Solution { vector&amp;lt;string&amp;gt; res;//在私有变量定义res在存结果， public: vector&amp;lt;string&amp;gt; generateParenthesis(int n)</description>
    </item>
    
    <item>
      <title>[lc]#20Valid_Parentheses</title>
      <link>https://chrishrz.github.io/post/lct20valid_parentheses/</link>
      <pubDate>Tue, 21 Apr 2020 11:49:21 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct20valid_parentheses/</guid>
      <description>题目 Given a string containing just the characters &amp;lsquo;(&#39;, &amp;lsquo;)&#39;, &amp;lsquo;{&#39;, &amp;lsquo;}&#39;, &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&#39;, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: Input: &amp;ldquo;()&amp;rdquo; Output: true Example 2: Input: &amp;ldquo;()[]{}&amp;rdquo; Output: true</description>
    </item>
    
    <item>
      <title>[lc]#17Letter_Combinations_of_a_Phone_Number</title>
      <link>https://chrishrz.github.io/post/lct17letter_combinations_of_a_phone_number/</link>
      <pubDate>Mon, 20 Apr 2020 20:25:18 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct17letter_combinations_of_a_phone_number/</guid>
      <description>题目 Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. 题解 时间复杂度$O(3^{N}+4^{M})$，N是</description>
    </item>
    
    <item>
      <title>[Lc]t14Longest_Common_Prefix</title>
      <link>https://chrishrz.github.io/post/lct14longest_common_prefix/</link>
      <pubDate>Sat, 18 Apr 2020 21:01:06 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct14longest_common_prefix/</guid>
      <description>题目 Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string &amp;ldquo;&amp;quot;. Example 1: Input: [&amp;ldquo;flower&amp;rdquo;,&amp;ldquo;flow&amp;rdquo;,&amp;ldquo;flight&amp;rdquo;] Output: &amp;ldquo;fl&amp;rdquo; Example 2: Input: [&amp;ldquo;dog&amp;rdquo;,&amp;ldquo;racecar&amp;rdquo;,&amp;ldquo;car&amp;rdquo;] Output: &amp;quot;&amp;rdquo; Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. 题解 1. 遍历法 时间复杂度</description>
    </item>
    
    <item>
      <title>[Lc]t67Add_Binary</title>
      <link>https://chrishrz.github.io/post/lct67add_binary/</link>
      <pubDate>Mon, 13 Apr 2020 22:36:11 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct67add_binary/</guid>
      <description>题目 Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. Example 1: Input: a = &amp;ldquo;11&amp;rdquo;, b = &amp;ldquo;1&amp;rdquo; Output: &amp;ldquo;100&amp;rdquo; Example 2: Input: a = &amp;ldquo;1010&amp;rdquo;, b = &amp;ldquo;1011&amp;rdquo; Output: &amp;ldquo;10101&amp;rdquo; Constraints: Each string consists only of &amp;lsquo;0&amp;rsquo; or &amp;lsquo;1&amp;rsquo; characters. 1 &amp;lt;= a.length, b.length &amp;lt;= 10^4 Each string is either &amp;ldquo;0&amp;rdquo; or</description>
    </item>
    
    <item>
      <title>[lc]#43Multiply_Strings</title>
      <link>https://chrishrz.github.io/post/lct43multiply_strings/</link>
      <pubDate>Sat, 11 Apr 2020 13:36:02 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct43multiply_strings/</guid>
      <description>题目 Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Example 1: Input: num1 = &amp;ldquo;2&amp;rdquo;, num2 = &amp;ldquo;3&amp;rdquo; Output: &amp;ldquo;6&amp;rdquo; Example 2: Input: num1 = &amp;ldquo;123&amp;rdquo;, num2 = &amp;ldquo;456&amp;rdquo; Output: &amp;ldquo;56088&amp;rdquo; Note: The length of both num1 and num2 is &amp;lt; 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do</description>
    </item>
    
    <item>
      <title>[lc]#12Integer_to_Roman</title>
      <link>https://chrishrz.github.io/post/lct12integer_to_roman/</link>
      <pubDate>Fri, 10 Apr 2020 00:13:43 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lct12integer_to_roman/</guid>
      <description>题目 Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is</description>
    </item>
    
  </channel>
</rss>