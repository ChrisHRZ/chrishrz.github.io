<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>树 on Focus-ChrisHRZ&#39;s blog</title>
    <link>https://chrishrz.github.io/tags/%E6%A0%91/</link>
    <description>Recent content in 树 on Focus-ChrisHRZ&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 20 May 2020 15:59:53 +0800</lastBuildDate>
    
	<atom:link href="https://chrishrz.github.io/tags/%E6%A0%91/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Lc]297二叉树的序列化与反序列化</title>
      <link>https://chrishrz.github.io/post/lc297%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Wed, 20 May 2020 15:59:53 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc297%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 先序遍历法 按先序遍历的顺序对数组进行序列化，遇到nullptr记位#</description>
    </item>
    
    <item>
      <title>[Lc]面试题34二叉树中和为某一值的路径</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9834%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Tue, 19 May 2020 17:23:22 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9834%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 这道题和113一样，可以用递归和迭代两种方法。这里再练习写一遍，详细题</description>
    </item>
    
    <item>
      <title>[Lc]面试题33二叉搜索树的后序遍历序列</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9833%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</link>
      <pubDate>Tue, 19 May 2020 12:13:21 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9833%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 分治递归法 二叉搜索树的性质见这里。后序遍历的顺序是左-&amp;gt;根-&amp;</description>
    </item>
    
    <item>
      <title>[Lc]面试题32_III从上到下打印二叉树III</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9832_iii%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91iii/</link>
      <pubDate>Mon, 18 May 2020 19:33:01 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9832_iii%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91iii/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 队列迭代法 比上一题再复杂一点，要区分奇偶行，偶数行从后面加数，奇数行</description>
    </item>
    
    <item>
      <title>[Lc]面试题32_II从上到下打印二叉树II</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9832_ii%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91ii/</link>
      <pubDate>Mon, 18 May 2020 19:24:27 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9832_ii%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91ii/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 队列迭代法 比上一题稍微复杂一点，不同层次要分开存，因此这里要多一个循</description>
    </item>
    
    <item>
      <title>[Lc]面试题28对称的二叉树</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9828%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 17 May 2020 13:21:13 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9828%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 这道题三种解法，递归，栈迭代（先序遍历），队列迭代（层次遍历）。与10</description>
    </item>
    
    <item>
      <title>[Lc]105从前序与中序遍历序列构造二叉树</title>
      <link>https://chrishrz.github.io/post/lc105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 10 May 2020 19:54:38 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题解 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 递归，先序的首字母是根节点，而中序的根节点区分左右子树，利用这个性质递</description>
    </item>
    
    <item>
      <title>[Lc]面试题07重建二叉树</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9807%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 10 May 2020 19:49:19 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9807%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 注意：本题与主站 105 题重复：(https://leetcode-cn.com/problems/construct-binary-tree</description>
    </item>
    
    <item>
      <title>[Lc]222完全二叉树的节点个数</title>
      <link>https://chrishrz.github.io/post/lc222%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Thu, 09 Apr 2020 11:03:58 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc222%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 class Solution { public: int countNodes(TreeNode* root) {//1.递归直接统计节点数 return root? 1+countNodes(root-&amp;gt;left)+countNodes(root-&amp;gt;right) : 0; } }; 2. 利用</description>
    </item>
    
    <item>
      <title>[Lc]226翻转二叉树</title>
      <link>https://chrishrz.github.io/post/lc226%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Wed, 08 Apr 2020 22:48:38 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc226%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 class Solution {//两种方法。1、递归法 public: TreeNode* invertTree(TreeNode* root) { if(!root) return nullptr;/</description>
    </item>
    
    <item>
      <title>[Lc]199二叉树的右视图</title>
      <link>https://chrishrz.github.io/post/lc199%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Wed, 08 Apr 2020 22:14:18 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc199%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; //本题借鉴#102层次遍历 class Solution { public: vector&amp;lt;int&amp;gt; rightSideView(TreeNode* root) { vector&amp;lt;int&amp;gt; res; if(!root) return res; queue&amp;lt;TreeNode*&amp;gt; q{{root}}; while(!q.empty()){ res.p</description>
    </item>
    
    <item>
      <title>[Lc]173二叉搜索树迭代器</title>
      <link>https://chrishrz.github.io/post/lc173%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Wed, 08 Apr 2020 18:20:18 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc173%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; //这道题就是写一个中序遍历，因为题目提到是搜索二叉树 class BSTIterator { stack&amp;lt;TreeNode*&amp;gt; s;//</description>
    </item>
    
    <item>
      <title>[Lc]129求根到叶子节点数字之和</title>
      <link>https://chrishrz.github.io/post/lc129%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Wed, 08 Apr 2020 13:24:46 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc129%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1.递归法 class Solution { public: int sumNumbers(TreeNode* root) {//两种方法。1.递归法 return DFSsunNum</description>
    </item>
    
    <item>
      <title>[Lc]117填充每个节点的下一个右侧节点指针II</title>
      <link>https://chrishrz.github.io/post/lc117%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88ii/</link>
      <pubDate>Wed, 08 Apr 2020 11:41:56 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc117%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88ii/</guid>
      <description>题目 题解 该题二叉树结构如下： // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; 1.递归法 //和#</description>
    </item>
    
    <item>
      <title>[Lc]116填充每个节点的下一个右侧节点指针</title>
      <link>https://chrishrz.github.io/post/lc116%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</link>
      <pubDate>Tue, 07 Apr 2020 22:15:10 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc116%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</guid>
      <description>题目 题解 该题二叉树结构如下： // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; 1. 递归法 //这道题</description>
    </item>
    
    <item>
      <title>[Lc]114二叉树展开为链表</title>
      <link>https://chrishrz.github.io/post/lc114%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 07 Apr 2020 20:12:38 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc114%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 先序递归法 //本题的顺序可以看出是先序遍历。 class Solution {//两种方法。1、</description>
    </item>
    
    <item>
      <title>[Lc]113路径总和2</title>
      <link>https://chrishrz.github.io/post/lc113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C2/</link>
      <pubDate>Fri, 27 Mar 2020 22:34:03 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C2/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 时间复杂度：$O(N)$ 空间复杂度：$O(N)$ 需要额外空间。</description>
    </item>
    
    <item>
      <title>[Lc]112路径总和</title>
      <link>https://chrishrz.github.io/post/lc112%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</link>
      <pubDate>Fri, 20 Mar 2020 20:06:36 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc112%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 时间复杂度: 最坏情况$O(N)$ 空间复杂度: 最坏情况$O(N)</description>
    </item>
    
    <item>
      <title>[Lc]111二叉树的最小深度</title>
      <link>https://chrishrz.github.io/post/lc111%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Wed, 18 Mar 2020 17:10:27 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc111%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 时间复杂度: $O(N)$ 空间复杂度: 最坏情况下，整棵树是非平衡的，例如每</description>
    </item>
    
    <item>
      <title>[Lc]110平衡二叉树</title>
      <link>https://chrishrz.github.io/post/lc110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 17 Mar 2020 16:32:45 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 时间复杂度: $O(n\log n)$ 空间复杂度: $O(n)$ class Solution { public: bool isBalanced(TreeNode* root) {//两种方法。1</description>
    </item>
    
    <item>
      <title>[Lc]107二叉树的层次遍历2</title>
      <link>https://chrishrz.github.io/post/lc174%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%862/</link>
      <pubDate>Tue, 17 Mar 2020 14:01:58 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc174%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%862/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 递归法有两种思路,一种直接翻转最终数组,一种在插入时就改变顺序</description>
    </item>
    
    <item>
      <title>[Lc]104二叉树的最大深度</title>
      <link>https://chrishrz.github.io/post/lc104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Tue, 17 Mar 2020 13:12:19 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 时间复杂度: $O(N)$ 空间复杂度: $O(N)$ class Solution {//这个题就是遍历然后存最大</description>
    </item>
    
    <item>
      <title>[Lc]103二叉树的锯齿层次遍历</title>
      <link>https://chrishrz.github.io/post/lc103%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</link>
      <pubDate>Tue, 17 Mar 2020 11:48:54 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc103%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1.迭代法 class Solution {//和#102类似，有所改变，有迭代法和递归法两种方法</description>
    </item>
    
    <item>
      <title>[Lc]102二叉树的层次遍历</title>
      <link>https://chrishrz.github.io/post/lc102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sun, 15 Mar 2020 15:03:26 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</guid>
      <description>题解 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 队列迭代法 class Solution {//两种方法。1、队列迭代法。 public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; if(!root) return res; /</description>
    </item>
    
    <item>
      <title>[Lc]101对称二叉树</title>
      <link>https://chrishrz.github.io/post/lc101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sat, 14 Mar 2020 19:54:18 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题解 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 递归法 class Solution {//三种方法。1、递归法。有点像#100 public: bool isSymmetric(TreeNode* root) { if(!root) return t</description>
    </item>
    
    <item>
      <title>[Lc]100相同的树</title>
      <link>https://chrishrz.github.io/post/lc100%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</link>
      <pubDate>Sat, 14 Mar 2020 19:27:58 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc100%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</guid>
      <description>题目 题解 这道题就是遍历。这里写一个先序遍历，其他遍历方式见相应例题。 二叉树的遍历包括DFS(深度优先搜索)的先序遍历、中序遍历、后序遍历。 还</description>
    </item>
    
    <item>
      <title>[Lc]98验证二叉搜索树</title>
      <link>https://chrishrz.github.io/post/lc98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sat, 14 Mar 2020 13:53:22 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题目 题解 TreeNode的定义： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ 1. 直接递归法 class Solution {//三种方法。1、直接递归</description>
    </item>
    
    <item>
      <title>[Lc]95不同的二叉搜索树2</title>
      <link>https://chrishrz.github.io/post/lc95%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</link>
      <pubDate>Sat, 14 Mar 2020 00:59:26 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc95%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</guid>
      <description>题目 题解 定义二叉树: //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; 1. 递归法 class Solution {//#96的升级版。两种方法。1、递归 public: vector&amp;lt;TreeNode*&amp;gt; generateTrees(int n) { vector&amp;lt;TreeNode*&amp;gt; ans; if(n==0) return a</description>
    </item>
    
    <item>
      <title>[Lc]96不同的二叉搜索树</title>
      <link>https://chrishrz.github.io/post/lc96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Fri, 13 Mar 2020 12:26:13 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>题目 题解 这道题是#95的简化版。#95要求写出所有的二叉搜索树，这道题只要求写出二叉搜索树的个数，因此要简单一点，其结题思路与卡塔兰数有关。</description>
    </item>
    
    <item>
      <title>[Lc]94/144/145二叉树的三种遍历</title>
      <link>https://chrishrz.github.io/post/lc94_144_145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 09 Mar 2020 11:28:56 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc94_144_145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/</guid>
      <description>题目 二叉树的遍历 简单地理解，满足以下两个条件的树就是二叉树： 本身是有序树； 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2； 下图即一颗</description>
    </item>
    
  </channel>
</rss>