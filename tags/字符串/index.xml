<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>字符串 on Focus-ChrisHRZ&#39;s blog</title>
    <link>https://chrishrz.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
    <description>Recent content in 字符串 on Focus-ChrisHRZ&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 09 May 2020 22:03:04 +0800</lastBuildDate>
    
	<atom:link href="https://chrishrz.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Lc]面试题05替换空格</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9805%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</link>
      <pubDate>Sat, 09 May 2020 22:03:04 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9805%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</guid>
      <description>题目 题解 1. 双指针法 先统计空格个数，然后扩容，然后用双指针挨个从前往后复制数据，不需要额外空间 时间复杂度$O(n)$,遍历两遍 空间复杂度$O(</description>
    </item>
    
    <item>
      <title>[Lc]171Excel表列序号</title>
      <link>https://chrishrz.github.io/post/lc171excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/</link>
      <pubDate>Fri, 08 May 2020 17:08:51 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc171excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/</guid>
      <description>题目 题解 和168正好相反嘛 这题就简单多了，挨个取字母变成数字就可以了，注意有： 每次是乘26 每次要+1，和168的原因一样，这个是伪26进制，</description>
    </item>
    
    <item>
      <title>[Lc]168Excel表列名称</title>
      <link>https://chrishrz.github.io/post/lc168excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</link>
      <pubDate>Fri, 08 May 2020 16:07:04 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc168excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</guid>
      <description>题目 题解 和171相反的一个题嘛，这个稍微难一点。 这道题就是十进制转26进制，但是有一些需要注意的问题 首先不能从前往后插入数字，即先放最大位，</description>
    </item>
    
    <item>
      <title>[Lc]166分数到小数</title>
      <link>https://chrishrz.github.io/post/lc166%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/</link>
      <pubDate>Fri, 08 May 2020 12:30:44 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc166%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/</guid>
      <description>题目 题解 这道题其实就是模拟笔算除法的过程，挨个位产生商，主要判断是否除尽或者产生了循环。 class Solution { public: string fractionToDecimal(int numerator, int denominator) { string res; if(numerator==0) return &amp;quot;0&amp;quot;; //用异或判断是否为负</description>
    </item>
    
    <item>
      <title>[Lc]165比较版本号</title>
      <link>https://chrishrz.github.io/post/lc165%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/</link>
      <pubDate>Thu, 07 May 2020 20:25:09 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc165%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/</guid>
      <description>题目 题解 1. stringstream法 用stringstream和getline切割字符串，并挨个比较，本来想用getline的，但是这样wh</description>
    </item>
    
    <item>
      <title>[Lc]151翻转字符串里的单词</title>
      <link>https://chrishrz.github.io/post/lc151%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</link>
      <pubDate>Thu, 07 May 2020 19:33:04 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc151%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</guid>
      <description>题目 题解 1. 双旋转单擦除法 题目要求空间复杂度$O(1)$，该方法符合，即先整体翻转全部字符串，再逐个单词串翻转，空格跳过，不同单词之间的空格自</description>
    </item>
    
    <item>
      <title>Cpp字符串转数字总结</title>
      <link>https://chrishrz.github.io/post/cpp%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E5%AD%97%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 07 May 2020 17:11:15 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/cpp%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E5%AD%97%E6%80%BB%E7%BB%93/</guid>
      <description>c语言转换形式 string str; int i = atoi(str.c_str());//string转int float f = atof(str.c_str());//strin</description>
    </item>
    
    <item>
      <title>[Lc]93复原IP地址</title>
      <link>https://chrishrz.github.io/post/lc93%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80/</link>
      <pubDate>Thu, 07 May 2020 12:46:45 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc93%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80/</guid>
      <description>题目 题解 这道题主要是递归然后剪枝，符合条件的放入结果，不符合就键值，主要是要确定几种不符合条件的情况 剩下的数字不够分的，比如还有2个数，但是</description>
    </item>
    
    <item>
      <title>[Lc]91解码方法</title>
      <link>https://chrishrz.github.io/post/lc91%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 07 May 2020 11:13:52 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc91%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</guid>
      <description>题目 题解 这道题也是dp，但是不用数组保存过去的状态，经过分析讨论当前状态只与前两个状态有关，所以只用存前两个状态即可，共有四种情况，详解见I</description>
    </item>
    
    <item>
      <title>[Lc]125验证回文串</title>
      <link>https://chrishrz.github.io/post/lc125%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</link>
      <pubDate>Wed, 06 May 2020 21:55:59 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc125%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</guid>
      <description>题目 题解 双指针，挨个比较，注意的是跳过非数字字母，还有大写字母要转化成小写 时间复杂度$O(n)$ 空间复杂度$O(1)$ 七个重要的c++内置函</description>
    </item>
    
    <item>
      <title>[Lc]87扰乱字符串</title>
      <link>https://chrishrz.github.io/post/lc87%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Wed, 06 May 2020 16:47:56 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc87%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目 题解 1. 递归法 就是通过递归左右子串，首先判断长度是否相等，不相等直接false；然后判断是否完全一样，一样直接true；然后判断排序后是否</description>
    </item>
    
    <item>
      <title>[Lc]72编辑距离</title>
      <link>https://chrishrz.github.io/post/lc72%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</link>
      <pubDate>Wed, 06 May 2020 13:18:11 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc72%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</guid>
      <description>题目 题解 时间复杂度$O(mn)$ 空间复杂度$O(mn)$，都是搞dp数组用的 class Solution { public: int minDistance(string word1, string word2) { int n=word1.size(), m=word2.size(); if(n*m==0) return n+m;//若一个为空，返回另一个</description>
    </item>
    
    <item>
      <title>[Lc]68文本左右对齐</title>
      <link>https://chrishrz.github.io/post/lc68%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90/</link>
      <pubDate>Wed, 06 May 2020 11:28:45 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc68%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90/</guid>
      <description>题目 题解 时间复杂度$O(N)$ 空间复杂度$O(maxWidth+N)$，用于暂存每行的结果和存结果 class Solution { public: vector&amp;lt;string&amp;gt; fullJustify(vector&amp;lt;string&amp;gt;&amp;amp; words, int maxWidth) { vector&amp;lt;string&amp;gt; res; if(words.empty()) return res; int left = 0;/</description>
    </item>
    
    <item>
      <title>[Lc]71简化路径</title>
      <link>https://chrishrz.github.io/post/lc71%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Wed, 06 May 2020 10:22:56 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc71%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</guid>
      <description>题目 题解 时间复杂度$O(N)$，遍历path 空间复杂度$O(N)$，两个n，t暂存路径，res存结果 class Solution { public: string simplifyPath(string path) { string res, tmp; if(path.empty()) return res;//特</description>
    </item>
    
    <item>
      <title>[Lc]58最后一个单词的长度</title>
      <link>https://chrishrz.github.io/post/lc58%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Tue, 05 May 2020 21:43:53 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc58%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</guid>
      <description>题目 题解 时间复杂度$O(k)$, k为最后一个单词的长度。 空间复杂度$O(1)$ 从后往前遍历，开始的0全部跳过，然后计数，再次遇到0跳出循环 class</description>
    </item>
    
    <item>
      <title>[Lc]49字母异位词分组</title>
      <link>https://chrishrz.github.io/post/lc49%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</link>
      <pubDate>Tue, 05 May 2020 12:59:21 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc49%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</guid>
      <description>题目 题解 1. unordered_map排序法 时间复杂度：排序的话算作$O(Klog{K})$,最外层的 for 循环，所以就是 $O(nKlog{K})</description>
    </item>
    
    <item>
      <title>[Lc]38外观数列</title>
      <link>https://chrishrz.github.io/post/lc38%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</link>
      <pubDate>Thu, 30 Apr 2020 21:11:40 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc38%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</guid>
      <description>题目 题解 时间复杂度$O(N*M)$ 空间复杂度$O(M_{end}+M_{end-1}) class Solution { public: string countAndSay(int n) { if(n == 0) return &amp;quot;&amp;quot;; string res = &amp;quot;1&amp;quo</description>
    </item>
    
    <item>
      <title>[Lc]28实现strStr()</title>
      <link>https://chrishrz.github.io/post/lc28%E5%AE%9E%E7%8E%B0strstr/</link>
      <pubDate>Fri, 24 Apr 2020 21:26:38 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc28%E5%AE%9E%E7%8E%B0strstr/</guid>
      <description>题目 题解 这道题说是简单题结果花了我两天，BF算法的确简单，但是其他的字符串匹配算法真的太复杂了。。。 1. 正则表达式 这个在leetcode上超时</description>
    </item>
    
    <item>
      <title>[Lc]22括号生成</title>
      <link>https://chrishrz.github.io/post/lc22%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</link>
      <pubDate>Tue, 21 Apr 2020 12:27:02 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc22%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</guid>
      <description>题目 题解 1.递归法 class Solution { vector&amp;lt;string&amp;gt; res;//在私有变量定义res在存结果， public: vector&amp;lt;string&amp;gt; generateParenthesis(int n) {//两种方法。1.递归 if(n==0) return res;//特殊情况 generateParenthesisDFS(n, n, &amp;quot;</description>
    </item>
    
    <item>
      <title>[Lc]20有效的括号</title>
      <link>https://chrishrz.github.io/post/lc20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Tue, 21 Apr 2020 11:49:21 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</guid>
      <description>题目 题解 时间复杂度$O(N)$ 空间复杂度$O(N)$ class Solution { public: bool isValid(string s) {//用栈 //不能挨个比较，因为有可能两个括号是交错的，用栈最合适 stack&amp;lt;char&amp;gt; par</description>
    </item>
    
    <item>
      <title>[Lc]17电话号码的字母组合</title>
      <link>https://chrishrz.github.io/post/lc17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</link>
      <pubDate>Mon, 20 Apr 2020 20:25:18 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</guid>
      <description>题目 题解 时间复杂度$O(3^{N}+4^{M})$，N是有三个字母的数字数量，M是有4个字母的数字数量。 空间复杂度$O(3^{N}+4^{M</description>
    </item>
    
    <item>
      <title>[Lc]14最长公共前缀</title>
      <link>https://chrishrz.github.io/post/lc14%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</link>
      <pubDate>Sat, 18 Apr 2020 21:01:06 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc14%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</guid>
      <description>题目 题解 1. 遍历法 时间复杂度$O(S)$（最坏情况）。S是所有字符数量。 空间复杂度$O(1)$ class Solution { public: string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) {//两种方法。1.遍历法 //这道</description>
    </item>
    
    <item>
      <title>[Lc]67二进制求和</title>
      <link>https://chrishrz.github.io/post/lc67%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</link>
      <pubDate>Mon, 13 Apr 2020 22:36:11 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc67%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</guid>
      <description>题目 题解 按位相加即可，注意字符串与整型的转换，数字小的填0，注意进位 时间复杂度$O(max{(aLen + bLen)})$ 空间复杂度$O(max{(aLen</description>
    </item>
    
    <item>
      <title>[Lc]43字符串相乘</title>
      <link>https://chrishrz.github.io/post/lc43%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</link>
      <pubDate>Sat, 11 Apr 2020 13:36:02 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc43%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</guid>
      <description>题目 题解 时间复杂度$O(mn)$ 空间复杂度$O(m+n)$ class Solution { public: string multiply(string num1, string num2) { string res = &amp;quot;&amp;quot;;//初始化结果res int len1 = num1.size(), len2</description>
    </item>
    
    <item>
      <title>[Lc]12整数转罗马数字</title>
      <link>https://chrishrz.github.io/post/lc12%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 10 Apr 2020 00:13:43 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc12%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</guid>
      <description>题目 题解 1. 分类法 每个数量级可以分为4类，1~3，4，5~8，9。因此就使用每个数量级取商然后选择合适的类别进行表达，余数进行下一个数量级商的</description>
    </item>
    
  </channel>
</rss>