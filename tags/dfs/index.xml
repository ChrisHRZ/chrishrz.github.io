<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DFS on Focus-ChrisHRZ&#39;s blog</title>
    <link>https://chrishrz.github.io/tags/dfs/</link>
    <description>Recent content in DFS on Focus-ChrisHRZ&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 21 May 2020 18:45:47 +0800</lastBuildDate>
    
	<atom:link href="https://chrishrz.github.io/tags/dfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Lc]52N皇后II</title>
      <link>https://chrishrz.github.io/post/lc52n%E7%9A%87%E5%90%8Eii/</link>
      <pubDate>Thu, 21 May 2020 18:45:47 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc52n%E7%9A%87%E5%90%8Eii/</guid>
      <description>题目 题解 这道题是51题的化简版，这里贴上51题的思路。唯一的区别就说不用统计所有的棋盘情况，而是遍历完一个分支就计数+1 这道题是很经典的一道</description>
    </item>
    
    <item>
      <title>[Lc]51N皇后</title>
      <link>https://chrishrz.github.io/post/lc51n%E7%9A%87%E5%90%8E/</link>
      <pubDate>Thu, 21 May 2020 11:23:26 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc51n%E7%9A%87%E5%90%8E/</guid>
      <description>题目 题解 这道题是很经典的一道题，思路就是dfs与回溯剪枝。这类回溯题的递归函数基本套路是这样的 判断是否终止并满足条件，满足了就加入res中 遍</description>
    </item>
    
    <item>
      <title>[Lc]面试题38字符串的排列</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9838%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</link>
      <pubDate>Wed, 20 May 2020 20:57:28 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9838%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</guid>
      <description>题目 题解 整体思路是从第一个数开始，不断地与后面的数进行交换（这个交换也包括与自己交换，即不交换），每一个数都有s.size()-start种</description>
    </item>
    
    <item>
      <title>[Lc]面试题37序列化二叉树</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9837%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Wed, 20 May 2020 16:54:15 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9837%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目 题解 二叉树结构如下： //Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 1. 先序遍历法 按先序遍历的顺序对数组进行序列化，遇到nullptr记位#</description>
    </item>
    
    <item>
      <title>[Lc]面试题36二叉搜索树与双向链表</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9836%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 20 May 2020 12:05:20 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9836%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 题解 节点定义如下： // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node() {} Node(int _val) { val = _val; left = NULL; right = NULL; } Node(int _val, Node* _left, Node* _right) { val = _val; left = _left; right = _right; } }; 这道题要利用二叉搜索树</description>
    </item>
    
    <item>
      <title>[Lc]426将二叉搜索树转化为排序的双向链表</title>
      <link>https://chrishrz.github.io/post/lc426%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 20 May 2020 11:58:34 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc426%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>题目 题解 节点定义如下： // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node() {} Node(int _val) { val = _val; left = NULL; right = NULL; } Node(int _val, Node* _left, Node* _right) { val = _val; left = _left; right = _right; } }; 这道题要利用二叉搜索树</description>
    </item>
    
    <item>
      <title>[Lc]面试题13机器人的运动范围</title>
      <link>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9813%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</link>
      <pubDate>Mon, 11 May 2020 21:31:13 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc%E9%9D%A2%E8%AF%95%E9%A2%9813%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</guid>
      <description>题目 题解 1. DFS 利用递归实现DFS搜索，注意要使用一个额外的矩阵保存已经访问过的位置，防止重复访问。当越界或者不满足数位条件或者已经访问过的时候</description>
    </item>
    
    <item>
      <title>[Lc]79单词搜索</title>
      <link>https://chrishrz.github.io/post/lc79%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Mon, 11 May 2020 18:18:49 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc79%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</guid>
      <description>题目 题解 这道题用递归，DFS，找到和首字母相同的就继续找下去，找到不同的就回溯再找首字母 时间复杂度：${\mathcal{O}}((M\ti</description>
    </item>
    
    <item>
      <title>[Lc]1254统计封闭岛屿的数目</title>
      <link>https://chrishrz.github.io/post/lc1254%E7%BB%9F%E8%AE%A1%E5%B0%81%E9%97%AD%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E7%9B%AE/</link>
      <pubDate>Tue, 28 Apr 2020 11:49:31 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc1254%E7%BB%9F%E8%AE%A1%E5%B0%81%E9%97%AD%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E7%9B%AE/</guid>
      <description>题目 题解 1. DFS 时间复杂度$O(MN)$ 空间复杂度$O(1)$ class Solution { public: int dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid, int row, int column){ int rows = grid.size(); int columns = grid[0].size();//计算行列数 if(row</description>
    </item>
    
    <item>
      <title>[Lc]200岛屿数量</title>
      <link>https://chrishrz.github.io/post/lc200%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</link>
      <pubDate>Mon, 27 Apr 2020 17:05:33 +0800</pubDate>
      
      <guid>https://chrishrz.github.io/post/lc200%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</guid>
      <description>题目 题解 1. DFS 时间复杂度$O(N*M)$ 空间复杂度$O(N*M)$（最坏情况） class Solution { public: void dfs(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid, int row, int column){ int rows = grid.size(); int columns = grid[0].size()</description>
    </item>
    
  </channel>
</rss>